

//-------------------------------------------------------------------------------------------------------------------
// xiApi header file
#ifndef __XIAPI_H
#define __XIAPI_H

#ifdef WIN32
#include <windows.h>
#else
// linux
#include "wintypedefs.h"
#endif
#include <stddef.h>
#include "m3Identify.h"
#ifdef XIAPI_EXPORTS
#define XIAPI __declspec(dllexport)
#else
#define XIAPI __declspec(dllimport)
#endif

typedef int XI_RETURN;

#ifdef __cplusplus
extern "C"
{
#endif

//-------------------------------------------------------------------------------------------------------------------
// xiApi parameters

// Basic
#define XI_PRM_EXPOSURE "exposure" // Exposure time in microseconds
#define XI_PRM_EXPOSURE_TIME_SELECTOR                                                                                  \
    "exposure_time_selector" // Selector for Exposure parameter XI_EXPOSURE_TIME_SELECTOR_TYPE
#define XI_PRM_EXPOSURE_BURST_COUNT "exposure_burst_count" // Sets the number of times of exposure in one frame.
#define XI_PRM_GAIN_SELECTOR                                                                                           \
    "gain_selector" // Gain selector for parameter Gain allows to select different type of gains. XI_GAIN_SELECTOR_TYPE
#define XI_PRM_GAIN "gain"                 // Gain in dB
#define XI_PRM_DOWNSAMPLING "downsampling" // Change image resolution by binning or skipping. XI_DOWNSAMPLING_VALUE
#define XI_PRM_DOWNSAMPLING_TYPE "downsampling_type" // Change image downsampling type. XI_DOWNSAMPLING_TYPE
#define XI_PRM_TEST_PATTERN_GENERATOR_SELECTOR                                                                         \
    "test_pattern_generator_selector" // Selects which test pattern generator is controlled by the test pattern feature.
                                      // XI_TEST_PATTERN_GENERATOR
#define XI_PRM_TEST_PATTERN                                                                                            \
    "test_pattern" // Selects which test pattern type is generated by the selected generator. XI_TEST_PATTERN
#define XI_PRM_IMAGE_DATA_FORMAT "imgdataformat"     // Output data format. XI_IMG_FORMAT
#define XI_PRM_SHUTTER_TYPE "shutter_type"           // Change sensor shutter type(CMOS sensor). XI_SHUTTER_TYPE
#define XI_PRM_SENSOR_TAPS "sensor_taps"             // Number of taps XI_SENSOR_TAP_CNT
#define XI_PRM_AEAG "aeag"                           // Automatic exposure/gain
#define XI_PRM_AEAG_ROI_OFFSET_X "aeag_roi_offset_x" // Automatic exposure/gain ROI offset X
#define XI_PRM_AEAG_ROI_OFFSET_Y "aeag_roi_offset_y" // Automatic exposure/gain ROI offset Y
#define XI_PRM_AEAG_ROI_WIDTH "aeag_roi_width"       // Automatic exposure/gain ROI Width
#define XI_PRM_AEAG_ROI_HEIGHT "aeag_roi_height"     // Automatic exposure/gain ROI Height
#define XI_PRM_SENS_DEFECTS_CORR_LIST_SELECTOR                                                                         \
    "bpc_list_selector" // Selector of list used by Sensor Defects Correction parameter
                        // XI_SENS_DEFFECTS_CORR_LIST_SELECTOR
#define XI_PRM_SENS_DEFECTS_CORR_LIST_CONTENT                                                                          \
    "sens_defects_corr_list_content"             // Sets/Gets sensor defects list in special text format
#define XI_PRM_SENS_DEFECTS_CORR "bpc"           // Correction of sensor defects (pixels, columns, rows) enable/disable
#define XI_PRM_AUTO_WB "auto_wb"                 // Automatic white balance
#define XI_PRM_MANUAL_WB "manual_wb"             // Calculates White Balance(xiGetImage function must be called)
#define XI_PRM_WB_ROI_OFFSET_X "wb_roi_offset_x" // White balance offset X
#define XI_PRM_WB_ROI_OFFSET_Y "wb_roi_offset_y" // White balance offset Y
#define XI_PRM_WB_ROI_WIDTH "wb_roi_width"       // White balance width
#define XI_PRM_WB_ROI_HEIGHT "wb_roi_height"     // White balance height
#define XI_PRM_WB_KR "wb_kr"                     // White balance red coefficient
#define XI_PRM_WB_KG "wb_kg"                     // White balance green coefficient
#define XI_PRM_WB_KB "wb_kb"                     // White balance blue coefficient
#define XI_PRM_WIDTH "width"                     // Width of the Image provided by the device (in pixels).
#define XI_PRM_HEIGHT "height"                   // Height of the Image provided by the device (in pixels).
#define XI_PRM_OFFSET_X "offsetX" // Horizontal offset from the origin to the area of interest (in pixels).
#define XI_PRM_OFFSET_Y "offsetY" // Vertical offset from the origin to the area of interest (in pixels).
#define XI_PRM_REGION_SELECTOR                                                                                         \
    "region_selector" // Selects Region in Multiple ROI which parameters are set by width, height, ... ,region mode
#define XI_PRM_REGION_MODE "region_mode"         // Activates/deactivates Region selected by Region Selector
#define XI_PRM_HORIZONTAL_FLIP "horizontal_flip" // Horizontal flip enable
#define XI_PRM_VERTICAL_FLIP "vertical_flip"     // Vertical flip enable
#define XI_PRM_INTERLINE_EXPOSURE_MODE                                                                                 \
    "interline_exposure_mode" // Selector for Exposure parameter XI_INTERLINE_EXPOSURE_MODE_TYPE
#define XI_PRM_FFC "ffc"      // Image flat field correction
#define XI_PRM_FFC_FLAT_FIELD_FILE_NAME "ffc_flat_field_file_name" // Set name of file to be applied for FFC processor.
#define XI_PRM_FFC_DARK_FIELD_FILE_NAME "ffc_dark_field_file_name" // Set name of file to be applied for FFC processor.
// Image Format
#define XI_PRM_BINNING_SELECTOR "binning_selector" // Binning engine selector. XI_BIN_SELECTOR
#define XI_PRM_BINNING_VERTICAL_MODE                                                                                   \
    "binning_vertical_mode" // Sets the mode to use to combine vertical pixel together. XI_BIN_MODE
#define XI_PRM_BINNING_VERTICAL                                                                                        \
    "binning_vertical" // Vertical Binning - number of vertical photo-sensitive cells to combine together.
#define XI_PRM_BINNING_HORIZONTAL_MODE                                                                                 \
    "binning_horizontal_mode" // Sets the mode to use to combine horizontal pixel together. XI_BIN_MODE
#define XI_PRM_BINNING_HORIZONTAL                                                                                      \
    "binning_horizontal" // Horizontal Binning - number of horizontal photo-sensitive cells to combine together.
#define XI_PRM_BINNING_HORIZONTAL_PATTERN                                                                              \
    "binning_horizontal_pattern"                                   // Binning horizontal pattern type. XI_BIN_PATTERN
#define XI_PRM_BINNING_VERTICAL_PATTERN "binning_vertical_pattern" // Binning vertical pattern type. XI_BIN_PATTERN
#define XI_PRM_DECIMATION_SELECTOR "decimation_selector"           // Decimation engine selector. XI_DEC_SELECTOR
#define XI_PRM_DECIMATION_VERTICAL                                                                                     \
    "decimation_vertical" // Vertical Decimation - vertical sub-sampling of the image - reduces the vertical resolution
                          // of the image by the specified vertical decimation factor.
#define XI_PRM_DECIMATION_HORIZONTAL                                                                                   \
    "decimation_horizontal" // Horizontal Decimation - horizontal sub-sampling of the image - reduces the horizontal
                            // resolution of the image by the specified vertical decimation factor.
#define XI_PRM_DECIMATION_HORIZONTAL_PATTERN                                                                           \
    "decimation_horizontal_pattern" // Decimation horizontal pattern type. XI_DEC_PATTERN
#define XI_PRM_DECIMATION_VERTICAL_PATTERN                                                                             \
    "decimation_vertical_pattern" // Decimation vertical pattern type. XI_DEC_PATTERN
// AE Setup
#define XI_PRM_EXP_PRIORITY "exp_priority" // Exposure priority (0.8 - exposure 80%, gain 20%).
#define XI_PRM_AG_MAX_LIMIT "ag_max_limit" // Maximum limit of gain in AEAG procedure
#define XI_PRM_AE_MAX_LIMIT "ae_max_limit" // Maximum time (us) used for exposure in AEAG procedure
#define XI_PRM_AEAG_LEVEL "aeag_level"     // Average intensity of output signal AEAG should achieve(in %)
// Performance
#define XI_PRM_LIMIT_BANDWIDTH "limit_bandwidth"           // Set/get bandwidth(data rate in Megabits)
#define XI_PRM_LIMIT_BANDWIDTH_MODE "limit_bandwidth_mode" // Bandwidth limit enabled XI_SWITCH
#define XI_PRM_SENSOR_DATA_BIT_DEPTH "sensor_bit_depth"    // Sensor output data bit depth. XI_BIT_DEPTH
#define XI_PRM_OUTPUT_DATA_BIT_DEPTH "output_bit_depth"    // Device output data bit depth. XI_BIT_DEPTH
#define XI_PRM_IMAGE_DATA_BIT_DEPTH                                                                                    \
    "image_data_bit_depth" // bit depth of data returned by function xiGetImage XI_BIT_DEPTH
#define XI_PRM_OUTPUT_DATA_PACKING                                                                                     \
    "output_bit_packing" // Device output data packing (or grouping) enabled. Packing could be enabled if
                         // output_data_bit_depth > 8 and packing capability is available.
#define XI_PRM_OUTPUT_DATA_PACKING_TYPE                                                                                \
    "output_bit_packing_type" // Data packing type. Some cameras supports only specific packing type.
                              // XI_OUTPUT_DATA_PACKING_TYPE
// Temperature
#define XI_PRM_IS_COOLED "iscooled"      // Returns 1 for cameras that support cooling.
#define XI_PRM_COOLING "cooling"         // Temperature control mode. XI_TEMP_CTRL_MODE_SELECTOR
#define XI_PRM_TARGET_TEMP "target_temp" // Set sensor target temperature for cooling.
#define XI_PRM_TEMP_SELECTOR                                                                                           \
    "temp_selector"        // Selector of mechanical point where thermometer is located. XI_TEMP_SELECTOR
#define XI_PRM_TEMP "temp" // Camera temperature (selected by XI_PRM_TEMP_SELECTOR)
#define XI_PRM_TEMP_CONTROL_MODE "device_temperature_ctrl_mode" // Temperature control mode. XI_TEMP_CTRL_MODE_SELECTOR
#define XI_PRM_CHIP_TEMP "chip_temp"                            // Camera sensor temperature
#define XI_PRM_HOUS_TEMP "hous_temp"                            // Camera housing temperature
#define XI_PRM_HOUS_BACK_SIDE_TEMP "hous_back_side_temp"        // Camera housing back side temperature
#define XI_PRM_SENSOR_BOARD_TEMP "sensor_board_temp"            // Camera sensor board temperature
#define XI_PRM_TEMP_ELEMENT_SEL                                                                                        \
    "device_temperature_element_sel" // Temperature element selector (TEC(Peltier), Fan). XI_TEMP_ELEMENT_SELECTOR
#define XI_PRM_TEMP_ELEMENT_VALUE                                                                                      \
    "device_temperature_element_val" // Temperature element value in percents of full control range
// Color Correction
#define XI_PRM_CMS "cms"               // Mode of color management system. XI_CMS_MODE
#define XI_PRM_CMS_INTENT "cms_intent" // Intent of color management system. XI_CMS_INTENT
#define XI_PRM_APPLY_CMS                                                                                               \
    "apply_cms" // Enable applying of CMS profiles to xiGetImage (see XI_PRM_INPUT_CMS_PROFILE,
                // XI_PRM_OUTPUT_CMS_PROFILE).
#define XI_PRM_INPUT_CMS_PROFILE "input_cms_profile"   // Filename for input cms profile (e.g. input.icc)
#define XI_PRM_OUTPUT_CMS_PROFILE "output_cms_profile" // Filename for output cms profile (e.g. input.icc)
#define XI_PRM_IMAGE_IS_COLOR "iscolor"                // Returns 1 for color cameras.
#define XI_PRM_COLOR_FILTER_ARRAY "cfa"     // Returns color filter array type of RAW data. XI_COLOR_FILTER_ARRAY
#define XI_PRM_GAMMAY "gammaY"              // Luminosity gamma
#define XI_PRM_GAMMAC "gammaC"              // Chromaticity gamma
#define XI_PRM_SHARPNESS "sharpness"        // Sharpness strength
#define XI_PRM_CC_MATRIX_00 "ccMTX00"       // Color Correction Matrix element [0][0]
#define XI_PRM_CC_MATRIX_01 "ccMTX01"       // Color Correction Matrix element [0][1]
#define XI_PRM_CC_MATRIX_02 "ccMTX02"       // Color Correction Matrix element [0][2]
#define XI_PRM_CC_MATRIX_03 "ccMTX03"       // Color Correction Matrix element [0][3]
#define XI_PRM_CC_MATRIX_10 "ccMTX10"       // Color Correction Matrix element [1][0]
#define XI_PRM_CC_MATRIX_11 "ccMTX11"       // Color Correction Matrix element [1][1]
#define XI_PRM_CC_MATRIX_12 "ccMTX12"       // Color Correction Matrix element [1][2]
#define XI_PRM_CC_MATRIX_13 "ccMTX13"       // Color Correction Matrix element [1][3]
#define XI_PRM_CC_MATRIX_20 "ccMTX20"       // Color Correction Matrix element [2][0]
#define XI_PRM_CC_MATRIX_21 "ccMTX21"       // Color Correction Matrix element [2][1]
#define XI_PRM_CC_MATRIX_22 "ccMTX22"       // Color Correction Matrix element [2][2]
#define XI_PRM_CC_MATRIX_23 "ccMTX23"       // Color Correction Matrix element [2][3]
#define XI_PRM_CC_MATRIX_30 "ccMTX30"       // Color Correction Matrix element [3][0]
#define XI_PRM_CC_MATRIX_31 "ccMTX31"       // Color Correction Matrix element [3][1]
#define XI_PRM_CC_MATRIX_32 "ccMTX32"       // Color Correction Matrix element [3][2]
#define XI_PRM_CC_MATRIX_33 "ccMTX33"       // Color Correction Matrix element [3][3]
#define XI_PRM_DEFAULT_CC_MATRIX "defccMTX" // Set default Color Correction Matrix
// Device IO
#define XI_PRM_TRG_SOURCE "trigger_source" // Defines source of trigger. XI_TRG_SOURCE
#define XI_PRM_TRG_SOFTWARE                                                                                            \
    "trigger_software" // Generates an internal trigger. XI_PRM_TRG_SOURCE must be set to TRG_SOFTWARE.
#define XI_PRM_TRG_SELECTOR "trigger_selector" // Selects the type of trigger. XI_TRG_SELECTOR
#define XI_PRM_TRG_OVERLAP                                                                                             \
    "trigger_overlap" // The mode of Trigger Overlap. This influences of trigger acception/rejection policy
                      // XI_TRG_OVERLAP
#define XI_PRM_ACQ_FRAME_BURST_COUNT                                                                                   \
    "acq_frame_burst_count" // Sets number of frames acquired by burst. This burst is used only if trigger is set to
                            // FrameBurstStart
#define XI_PRM_TIMESTAMP "timestamp" // Current value of the device timestamp counter
// GPIO Setup
#define XI_PRM_GPI_SELECTOR "gpi_selector"                                 // Selects GPI XI_GPI_SELECTOR
#define XI_PRM_GPI_MODE "gpi_mode"                                         // Defines GPI functionality XI_GPI_MODE
#define XI_PRM_GPI_LEVEL "gpi_level"                                       // GPI level
#define XI_PRM_GPI_LEVEL_AT_IMAGE_EXP_START "gpi_level_at_image_exp_start" // GPI Level at image exposure start
#define XI_PRM_GPI_LEVEL_AT_IMAGE_EXP_END "gpi_level_at_image_exp_end"     // GPI Level at image exposure end
#define XI_PRM_GPO_SELECTOR "gpo_selector"                                 // Selects GPO XI_GPO_SELECTOR
#define XI_PRM_GPO_MODE "gpo_mode"                                         // Defines GPO functionality XI_GPO_MODE
#define XI_PRM_LED_SELECTOR "led_selector"                                 // Selects LED XI_LED_SELECTOR
#define XI_PRM_LED_MODE "led_mode"                                         // Defines LED functionality XI_LED_MODE
#define XI_PRM_DEBOUNCE_EN "dbnc_en"                                       // Enable/Disable debounce to selected GPI
// Debounce Setup
#define XI_PRM_DEBOUNCE_T0 "dbnc_t0"   // Debounce time (x * 10us)
#define XI_PRM_DEBOUNCE_T1 "dbnc_t1"   // Debounce time (x * 10us)
#define XI_PRM_DEBOUNCE_POL "dbnc_pol" // Debounce polarity (pol = 1 t0 - falling edge, t1 - rising edge)
// Lens Control
#define XI_PRM_LENS_MODE                                                                                               \
    "lens_mode" // Status of lens control interface. This shall be set to XI_ON before any Lens operations.
#define XI_PRM_LENS_APERTURE_VALUE                                                                                     \
    "lens_aperture_value" // Current lens aperture value in stops. Examples: 2.8, 4, 5.6, 8, 11
#define XI_PRM_LENS_APERTURE_INDEX "lens_aperture_index" // Current aperture index as reported by lens.
#define XI_PRM_LENS_FOCUS_MOVEMENT_VALUE                                                                               \
    "lens_focus_movement_value" // Lens current focus movement value to be used by XI_PRM_LENS_FOCUS_MOVE in motor
                                // steps.
#define XI_PRM_LENS_FOCUS_MOVE                                                                                         \
    "lens_focus_move" // Moves lens focus motor by steps set in XI_PRM_LENS_FOCUS_MOVEMENT_VALUE.
#define XI_PRM_LENS_FOCUS_DISTANCE "lens_focus_distance" // Lens focus distance in cm.
#define XI_PRM_LENS_FOCAL_LENGTH "lens_focal_length"     // Lens focal distance in mm.
#define XI_PRM_LENS_FEATURE_SELECTOR                                                                                   \
    "lens_feature_selector" // Selects the current feature which is accessible by XI_PRM_LENS_FEATURE. XI_LENS_FEATURE
#define XI_PRM_LENS_FEATURE                                                                                            \
    "lens_feature" // Allows access to lens feature value currently selected by XI_PRM_LENS_FEATURE_SELECTOR.
// Device info parameters
#define XI_PRM_DEVICE_NAME "device_name"               // Return device name
#define XI_PRM_DEVICE_TYPE "device_type"               // Return device type
#define XI_PRM_DEVICE_MODEL_ID "device_model_id"       // Return device model id
#define XI_PRM_SENSOR_MODEL_ID "sensor_model_id"       // Return device sensor model id
#define XI_PRM_DEVICE_SN "device_sn"                   // Return device serial number
#define XI_PRM_DEVICE_SENS_SN "device_sens_sn"         // Return sensor serial number
#define XI_PRM_DEVICE_INSTANCE_PATH "device_inst_path" // Return device system instance path.
#define XI_PRM_DEVICE_LOCATION_PATH "device_loc_path"  // Represents the location of the device in the device tree.
#define XI_PRM_DEVICE_USER_ID "device_user_id"         // Return custom ID of camera.
#define XI_PRM_DEVICE_MANIFEST "device_manifest"       // Return device capability description XML.
#define XI_PRM_IMAGE_USER_DATA "image_user_data" // User image data at image header to track parameters synchronization.
// Device acquisition settings
#define XI_PRM_IMAGE_DATA_FORMAT_RGB32_ALPHA                                                                           \
    "imgdataformatrgb32alpha" // The alpha channel of RGB32 output image format.
#define XI_PRM_IMAGE_PAYLOAD_SIZE                                                                                      \
    "imgpayloadsize" // Buffer size in bytes sufficient for output image returned by xiGetImage
#define XI_PRM_TRANSPORT_PIXEL_FORMAT                                                                                  \
    "transport_pixel_format" // Current format of pixels on transport layer. XI_GenTL_Image_Format_e
#define XI_PRM_TRANSPORT_DATA_TARGET                                                                                   \
    "transport_data_target" // Target selector for data - CPU RAM or GPU RAM XI_TRANSPORT_DATA_TARGET_MODE
#define XI_PRM_SENSOR_CLOCK_FREQ_HZ "sensor_clock_freq_hz" // Sensor clock frequency in Hz.
#define XI_PRM_SENSOR_CLOCK_FREQ_INDEX                                                                                 \
    "sensor_clock_freq_index" // Sensor clock frequency index. Sensor with selected frequencies have possibility to set
                              // the frequency only by this index.
#define XI_PRM_SENSOR_OUTPUT_CHANNEL_COUNT                                                                             \
    "sensor_output_channel_count"                  // Number of output channels from sensor used for data transfer.
                                                   // XI_SENSOR_OUTPUT_CHANNEL_COUNT
#define XI_PRM_FRAMERATE "framerate"               // Define framerate in Hz
#define XI_PRM_COUNTER_SELECTOR "counter_selector" // Select counter XI_COUNTER_SELECTOR
#define XI_PRM_COUNTER_VALUE "counter_value"       // Counter status
#define XI_PRM_ACQ_TIMING_MODE "acq_timing_mode"   // Type of sensor frames timing. XI_ACQ_TIMING_MODE
#define XI_PRM_AVAILABLE_BANDWIDTH                                                                                     \
    "available_bandwidth"                    // Measure and return available interface bandwidth(int Megabits)
#define XI_PRM_BUFFER_POLICY "buffer_policy" // Data move policy XI_BP
#define XI_PRM_LUT_EN "LUTEnable"            // Activates LUT.
#define XI_PRM_LUT_INDEX "LUTIndex"          // Control the index (offset) of the coefficient to access in the LUT.
#define XI_PRM_LUT_VALUE "LUTValue"          // Value at entry LUTIndex of the LUT
#define XI_PRM_TRG_DELAY                                                                                               \
    "trigger_delay" // Specifies the delay in microseconds (us) to apply after the trigger reception before activating
                    // it.
#define XI_PRM_TS_RST_MODE "ts_rst_mode" // Defines how TimeStamp reset engine will be armed XI_TS_RST_MODE
#define XI_PRM_TS_RST_SOURCE                                                                                           \
    "ts_rst_source" // Defines which source will be used for timestamp reset. Writing this parameter will trigger
                    // settings of engine (arming) XI_TS_RST_SOURCE
// Extended Device parameters
#define XI_PRM_IS_DEVICE_EXIST "isexist"         // Returns 1 if camera connected and works properly.
#define XI_PRM_ACQ_BUFFER_SIZE "acq_buffer_size" // Acquisition buffer size in buffer_size_unit. Default bytes.
#define XI_PRM_ACQ_BUFFER_SIZE_UNIT                                                                                    \
    "acq_buffer_size_unit" // Acquisition buffer size unit in bytes. Default 1. E.g. Value 1024 means that buffer_size
                           // is in KiBytes
#define XI_PRM_ACQ_TRANSPORT_BUFFER_SIZE "acq_transport_buffer_size" // Acquisition transport buffer size in bytes
#define XI_PRM_ACQ_TRANSPORT_PACKET_SIZE "acq_transport_packet_size" // Acquisition transport packet size in bytes
#define XI_PRM_BUFFERS_QUEUE_SIZE "buffers_queue_size"               // Queue of field/frame buffers
#define XI_PRM_ACQ_TRANSPORT_BUFFER_COMMIT                                                                             \
    "acq_transport_buffer_commit" // Total number of buffers to be committed to transport layer. Increasing can enhance
                                  // transport capacity. E.g. on USB
#define XI_PRM_RECENT_FRAME "recent_frame" // GetImage returns most recent frame
#define XI_PRM_DEVICE_RESET "device_reset" // Resets the camera to default state.
// Sensor Defects Correction
#define XI_PRM_COLUMN_FPN_CORRECTION "column_fpn_correction" // Correction of column FPN XI_SWITCH
#define XI_PRM_ROW_FPN_CORRECTION "row_fpn_correction"       // Correction of row FPN XI_SWITCH
// Sensor features
#define XI_PRM_SENSOR_MODE                                                                                             \
    "sensor_mode"        // Current sensor mode. Allows to select sensor mode by one integer. Setting of this parameter
                         // affects: image dimensions and downsampling. XI_SENSOR_MODE
#define XI_PRM_HDR "hdr" // Enable High Dynamic Range feature.
#define XI_PRM_HDR_KNEEPOINT_COUNT "hdr_kneepoint_count" // The number of kneepoints in the PWLR.
#define XI_PRM_HDR_T1 "hdr_t1"                           // position of first kneepoint(in % of XI_PRM_EXPOSURE)
#define XI_PRM_HDR_T2 "hdr_t2"                           // position of second kneepoint (in % of XI_PRM_EXPOSURE)
#define XI_PRM_KNEEPOINT1 "hdr_kneepoint1"               // value of first kneepoint (% of sensor saturation)
#define XI_PRM_KNEEPOINT2 "hdr_kneepoint2"               // value of second kneepoint (% of sensor saturation)
#define XI_PRM_IMAGE_BLACK_LEVEL                                                                                       \
    "image_black_level" // Last image black level counts (same as in XI_IMG). Setting can be used only for Offline
                        // Processing.
// Version info
#define XI_PRM_API_VERSION "api_version"       // Returns version of API.
#define XI_PRM_DRV_VERSION "drv_version"       // Returns version of current device driver.
#define XI_PRM_MCU1_VERSION "version_mcu1"     // Returns version of MCU1 firmware.
#define XI_PRM_MCU2_VERSION "version_mcu2"     // Returns version of MCU2 firmware.
#define XI_PRM_MCU3_VERSION "version_mcu3"     // Returns version of MCU3 firmware.
#define XI_PRM_FPGA1_VERSION "version_fpga1"   // Returns version of FPGA firmware currently running.
#define XI_PRM_XMLMAN_VERSION "version_xmlman" // Returns version of XML manifest.
#define XI_PRM_HW_REVISION "hw_revision"       // Returns hardware revision number.
// API features
#define XI_PRM_DEBUG_LEVEL "debug_level"                               // Set debug level XI_DEBUG_LEVEL
#define XI_PRM_AUTO_BANDWIDTH_CALCULATION "auto_bandwidth_calculation" // Automatic bandwidth calculation,
#define XI_PRM_NEW_PROCESS_CHAIN_ENABLE                                                                                \
    "new_process_chain_enable" // Enables (2015/FAPI) processing chain for MQ MU cameras. If disabled - legacy
                               // processing 2006 is used.
#define XI_PRM_PROC_NUM_THREADS "proc_num_threads" // Number of threads per image processor
// Camera FFS
#define XI_PRM_READ_FILE_FFS "read_file_ffs"   // Read file from camera flash filesystem.
#define XI_PRM_WRITE_FILE_FFS "write_file_ffs" // Write file to camera flash filesystem.
#define XI_PRM_FFS_FILE_NAME "ffs_file_name"   // Set name of file to be written/read from camera FFS.
#define XI_PRM_FFS_FILE_ID "ffs_file_id"       // File number.
#define XI_PRM_FFS_FILE_SIZE "ffs_file_size"   // Size of file.
#define XI_PRM_FREE_FFS_SIZE "free_ffs_size"   // Size of free camera FFS.
#define XI_PRM_USED_FFS_SIZE "used_ffs_size"   // Size of used camera FFS.
#define XI_PRM_FFS_ACCESS_KEY "ffs_access_key" // Setting of key enables file operations on some cameras.
// APIContextControl
#define XI_PRM_API_CONTEXT_LIST                                                                                        \
    "xiapi_context_list" // List of current parameters settings context - parameters with values. Used for offline
                         // processing.
// Sensor Control
#define XI_PRM_SENSOR_FEATURE_SELECTOR                                                                                 \
    "sensor_feature_selector" // Selects the current feature which is accessible by XI_PRM_SENSOR_FEATURE_VALUE.
                              // XI_SENSOR_FEATURE_SELECTOR
#define XI_PRM_SENSOR_FEATURE_VALUE                                                                                    \
    "sensor_feature_value" // Allows access to sensor feature value currently selected by
                           // XI_PRM_SENSOR_FEATURE_SELECTOR.
// Extended Features
#define XI_PRM_ACQUISITION_STATUS_SELECTOR                                                                             \
    "acquisition_status_selector" // Selects the internal acquisition signal to read using XI_PRM_ACQUISITION_STATUS.
                                  // XI_ACQUISITION_STATUS_SELECTOR
#define XI_PRM_ACQUISITION_STATUS "acquisition_status" // Acquisition status(True/False) XI_SWITCH
#define XI_PRM_DP_UNIT_SELECTOR "dp_unit_selector"     // Data Pipe Unit Selector. XI_DP_UNIT_SELECTOR
#define XI_PRM_DP_PROC_SELECTOR "dp_proc_selector"     // Data Pipe Processor Selector. XI_DP_PROC_SELECTOR
#define XI_PRM_DP_PARAM_SELECTOR "dp_param_selector"   // Data Pipe Processor parameter Selector. XI_DP_PARAM_SELECTOR
#define XI_PRM_DP_PARAM_VALUE "dp_param_value"         // Data Pipe processor parameter value
#define XI_PRM_GENTL_DATASTREAM_ENABLED "gentl_stream_en" // Enable or disable low level streaming via GenTL.
#define XI_PRM_GENTL_DATASTREAM_CONTEXT                                                                                \
    "gentl_stream_context" // Get GenTL stream context pointer for low level streaming
// User Set Control
#define XI_PRM_USER_SET_SELECTOR                                                                                       \
    "user_set_selector" // Selects the feature User Set to load, save or configure. XI_USER_SET_SELECTOR
#define XI_PRM_USER_SET_LOAD                                                                                           \
    "user_set_load" // Loads the User Set specified by User Set Selector to the device and makes it active.

    //-------------------------------------------------------------------------------------------------------------------
    // Error codes xiApi
    typedef enum
    {
        XI_OK = 0,                           // Function call succeeded
        XI_INVALID_HANDLE = 1,               // Invalid handle
        XI_READREG = 2,                      // Register read error
        XI_WRITEREG = 3,                     // Register write error
        XI_FREE_RESOURCES = 4,               // Freeing resources error
        XI_FREE_CHANNEL = 5,                 // Freeing channel error
        XI_FREE_BANDWIDTH = 6,               // Freeing bandwith error
        XI_READBLK = 7,                      // Read block error
        XI_WRITEBLK = 8,                     // Write block error
        XI_NO_IMAGE = 9,                     // No image
        XI_TIMEOUT = 10,                     // Timeout
        XI_INVALID_ARG = 11,                 // Invalid arguments supplied
        XI_NOT_SUPPORTED = 12,               // Not supported
        XI_ISOCH_ATTACH_BUFFERS = 13,        // Attach buffers error
        XI_GET_OVERLAPPED_RESULT = 14,       // Overlapped result
        XI_MEMORY_ALLOCATION = 15,           // Memory allocation error
        XI_DLLCONTEXTISNULL = 16,            // DLL context is NULL
        XI_DLLCONTEXTISNONZERO = 17,         // DLL context is non zero
        XI_DLLCONTEXTEXIST = 18,             // DLL context exists
        XI_TOOMANYDEVICES = 19,              // Too many devices connected
        XI_ERRORCAMCONTEXT = 20,             // Camera context error
        XI_UNKNOWN_HARDWARE = 21,            // Unknown hardware
        XI_INVALID_TM_FILE = 22,             // Invalid TM file
        XI_INVALID_TM_TAG = 23,              // Invalid TM tag
        XI_INCOMPLETE_TM = 24,               // Incomplete TM
        XI_BUS_RESET_FAILED = 25,            // Bus reset error
        XI_NOT_IMPLEMENTED = 26,             // Not implemented
        XI_SHADING_TOOBRIGHT = 27,           // Shading is too bright
        XI_SHADING_TOODARK = 28,             // Shading is too dark
        XI_TOO_LOW_GAIN = 29,                // Gain is too low
        XI_INVALID_BPL = 30,                 // Invalid sensor defect correction list
        XI_BPL_REALLOC = 31,                 // Error while sensor defect correction list reallocation
        XI_INVALID_PIXEL_LIST = 32,          // Invalid pixel list
        XI_INVALID_FFS = 33,                 // Invalid Flash File System
        XI_INVALID_PROFILE = 34,             // Invalid profile
        XI_INVALID_CALIBRATION = 35,         // Invalid calibration
        XI_INVALID_BUFFER = 36,              // Invalid buffer
        XI_INVALID_DATA = 38,                // Invalid data
        XI_TGBUSY = 39,                      // Timing generator is busy
        XI_IO_WRONG = 40,                    // Wrong operation open/write/read/close
        XI_ACQUISITION_ALREADY_UP = 41,      // Acquisition already started
        XI_OLD_DRIVER_VERSION = 42,          // Old version of device driver installed to the system.
        XI_GET_LAST_ERROR = 43,              // To get error code please call GetLastError function.
        XI_CANT_PROCESS = 44,                // Data cannot be processed
        XI_ACQUISITION_STOPED = 45,          // Acquisition is stopped. It needs to be started to perform operation.
        XI_ACQUISITION_STOPED_WERR = 46,     // Acquisition has been stopped with an error.
        XI_INVALID_INPUT_ICC_PROFILE = 47,   // Input ICC profile missing or corrupted
        XI_INVALID_OUTPUT_ICC_PROFILE = 48,  // Output ICC profile missing or corrupted
        XI_DEVICE_NOT_READY = 49,            // Device not ready to operate
        XI_SHADING_TOOCONTRAST = 50,         // Shading is too contrast
        XI_ALREADY_INITIALIZED = 51,         // Module already initialized
        XI_NOT_ENOUGH_PRIVILEGES = 52,       // Application does not have enough privileges (one or more app)
        XI_NOT_COMPATIBLE_DRIVER = 53,       // Installed driver is not compatible with current software
        XI_TM_INVALID_RESOURCE = 54,         // TM file was not loaded successfully from resources
        XI_DEVICE_HAS_BEEN_RESETED = 55,     // Device has been reset, abnormal initial state
        XI_NO_DEVICES_FOUND = 56,            // No Devices Found
        XI_RESOURCE_OR_FUNCTION_LOCKED = 57, // Resource (device) or function locked by mutex
        XI_BUFFER_SIZE_TOO_SMALL = 58,       // Buffer provided by user is too small
        XI_COULDNT_INIT_PROCESSOR = 59,      // Could not initialize processor.
        XI_NOT_INITIALIZED = 60,      // The object/module/procedure/process being referred to has not been started.
        XI_RESOURCE_NOT_FOUND = 61,   // Resource not found(could be processor, file, item...).
        XI_UNKNOWN_PARAM = 100,       // Unknown parameter
        XI_WRONG_PARAM_VALUE = 101,   // Wrong parameter value
        XI_WRONG_PARAM_TYPE = 103,    // Wrong parameter type
        XI_WRONG_PARAM_SIZE = 104,    // Wrong parameter size
        XI_BUFFER_TOO_SMALL = 105,    // Input buffer is too small
        XI_NOT_SUPPORTED_PARAM = 106, // Parameter is not supported
        XI_NOT_SUPPORTED_PARAM_INFO = 107,  // Parameter info not supported
        XI_NOT_SUPPORTED_DATA_FORMAT = 108, // Data format is not supported
        XI_READ_ONLY_PARAM = 109,           // Read only parameter
        XI_BANDWIDTH_NOT_SUPPORTED = 111,   // This camera does not support currently available bandwidth
        XI_INVALID_FFS_FILE_NAME = 112,     // FFS file selector is invalid or NULL
        XI_FFS_FILE_NOT_FOUND = 113,        // FFS file not found
        XI_PARAM_NOT_SETTABLE = 114,        // Parameter value cannot be set (might be out of range or invalid).
        XI_SAFE_POLICY_NOT_SUPPORTED =
            115, // Safe buffer policy is not supported. E.g. when transport target is set to GPU (GPUDirect).
        XI_GPUDIRECT_NOT_AVAILABLE =
            116, // GPUDirect is not available. E.g. platform isn't supported or CUDA toolkit isn't installed.
        XI_PROC_OTHER_ERROR = 201,               // Processing error - other
        XI_PROC_PROCESSING_ERROR = 202,          // Error while image processing.
        XI_PROC_INPUT_FORMAT_UNSUPPORTED = 203,  // Input format is not supported for processing.
        XI_PROC_OUTPUT_FORMAT_UNSUPPORTED = 204, // Output format is not supported for processing.
        XI_OUT_OF_RANGE = 205,                   // Parameter value is out of range

    } XI_RET;

    //-------------------------------------------------------------------------------------------------------------------
    // xiAPI enumerators
    // Downsampling value enumerator.
    typedef enum
    {
        XI_DWN_1x1 = 1,    // 1 sensor pixel = 1 image pixel
        XI_DWN_2x2 = 2,    // 2x2 sensor pixels = 1 image pixel
        XI_DWN_3x3 = 3,    // Downsampling 3x3.
        XI_DWN_4x4 = 4,    // 4x4 sensor pixels = 1 image pixel
        XI_DWN_5x5 = 5,    // Downsampling 5x5.
        XI_DWN_6x6 = 6,    // Downsampling 6x6.
        XI_DWN_7x7 = 7,    // Downsampling 7x7.
        XI_DWN_8x8 = 8,    // Downsampling 8x8.
        XI_DWN_9x9 = 9,    // Downsampling 9x9.
        XI_DWN_10x10 = 10, // Downsampling 10x10.
        XI_DWN_16x16 = 16, // Downsampling 16x16.

    } XI_DOWNSAMPLING_VALUE;

    // Test Pattern Generator
    typedef enum
    {
        XI_TESTPAT_GEN_SENSOR = 0, // Sensor test pattern generator
        XI_TESTPAT_GEN_FPGA = 1,   //  FPGA Test Pattern Generator

    } XI_TEST_PATTERN_GENERATOR;

    // Test Pattern Type
    typedef enum
    {
        XI_TESTPAT_OFF = 0,             //  Testpattern turned off.
        XI_TESTPAT_BLACK = 1,           //  Image is filled with darkest possible image.
        XI_TESTPAT_WHITE = 2,           //  Image is filled with brightest possible image.
        XI_TESTPAT_GREY_HORIZ_RAMP = 3, //  Image is filled horizontally with an image that goes from the darkest
                                        //  possible value to the brightest.
        XI_TESTPAT_GREY_VERT_RAMP =
            4, //  Image is filled vertically with an image that goes from the darkest possible value to the brightest.
        XI_TESTPAT_GREY_HORIZ_RAMP_MOVING = 5, //  Image is filled horizontally with an image that goes from the darkest
                                               //  possible value to the brightest and moves from left to right.
        XI_TESTPAT_GREY_VERT_RAMP_MOVING = 6,  //  Image is filled vertically with an image that goes from the darkest
                                               //  possible value to the brightest and moves from left to right.
        XI_TESTPAT_HORIZ_LINE_MOVING = 7,      //  A moving horizontal line is superimposed on the live image.
        XI_TESTPAT_VERT_LINE_MOVING = 8,       //  A moving vertical line is superimposed on the live image.
        XI_TESTPAT_COLOR_BAR = 9, //  Image is filled with stripes of color including White, Black, Red, Green, Blue,
                                  //  Cyan, Magenta and Yellow.
        XI_TESTPAT_FRAME_COUNTER = 10,       //  A frame counter is superimposed on the live image.
        XI_TESTPAT_DEVICE_SPEC_COUNTER = 11, //  128bit counter.

    } XI_TEST_PATTERN;

    // Decimation Pattern Format
    typedef enum
    {
        XI_DEC_MONO = 1,  // adjacent pixels are decimated
        XI_DEC_BAYER = 2, // 	Bayer pattern is preserved during pixel decimation

    } XI_DEC_PATTERN;

    // Binning Pattern Format
    typedef enum
    {
        XI_BIN_MONO = 1,  // adjacent pixels are combined
        XI_BIN_BAYER = 2, // Bayer pattern is preserved during pixel combining

    } XI_BIN_PATTERN;

    // Binning Engine Selector
    typedef enum
    {
        XI_BIN_SELECT_SENSOR = 0,      // parameters for image sensor binning are selected
        XI_BIN_SELECT_DEVICE_FPGA = 1, // parameters for device (camera) FPGA decimation are selected
        XI_BIN_SELECT_HOST_CPU = 2,    // parameters for Host CPU binning are selected

    } XI_BIN_SELECTOR;

    // Selects binning mode; to be used with
    typedef enum
    {
        XI_BIN_MODE_SUM = 0, // The response from the combined pixels will be added, resulting in increased sensitivity.
        XI_BIN_MODE_AVERAGE =
            1, // The response from the combined pixels will be averaged, resulting in increased signal/noise ratio.

    } XI_BIN_MODE;

    // Decimation Engine Selector
    typedef enum
    {
        XI_DEC_SELECT_SENSOR = 0,      // parameters for image sensor decimation are selected
        XI_DEC_SELECT_DEVICE_FPGA = 1, // parameters for device (camera) FPGA decimation are selected
        XI_DEC_SELECT_HOST_CPU = 2,    // parameters for Host CPU decimation are selected

    } XI_DEC_SELECTOR;

    // Sensor tap count enumerator.
    typedef enum
    {
        XI_TAP_CNT_1 = 1, // 1 sensor tap selected.
        XI_TAP_CNT_2 = 2, // 2 sensor taps selected.
        XI_TAP_CNT_4 = 4, // 4 sensor taps selected.

    } XI_SENSOR_TAP_CNT;

    // Bit depth enumerator.
    typedef enum
    {
        XI_BPP_8 = 8,   // 8 bit per pixel
        XI_BPP_9 = 9,   // 9 bit per pixel
        XI_BPP_10 = 10, // 10 bit per pixel
        XI_BPP_11 = 11, // 11 bit per pixel
        XI_BPP_12 = 12, // 12 bit per pixel
        XI_BPP_14 = 14, // 14 bit per pixel
        XI_BPP_16 = 16, // 16 bit per pixel
        XI_BPP_24 = 24, // 24 bit per pixel
        XI_BPP_32 = 32, // 32 bit per pixel

    } XI_BIT_DEPTH;

    // Debug level enumerator.
    typedef enum
    {
        XI_DL_DETAIL = 0,     // (see Note1)
        XI_DL_TRACE = 1,      // Prints errors, warnings and important informations
        XI_DL_WARNING = 2,    // Prints all errors and warnings
        XI_DL_ERROR = 3,      // Prints all errors
        XI_DL_FATAL = 4,      // Prints only important errors
        XI_DL_DISABLED = 100, // Prints no messages

    } XI_DEBUG_LEVEL;

    // Image output format enumerator.
    typedef enum
    {
        XI_MONO8 = 0,      // 8 bits per pixel. 	[Intensity] (see Note5,Note6)
        XI_MONO16 = 1,     // 16 bits per pixel. [Intensity LSB] [Intensity MSB] (see Note5,Note6)
        XI_RGB24 = 2,      // RGB data format. [Blue][Green][Red] (see Note5)
        XI_RGB32 = 3,      // RGBA data format. 	[Blue][Green][Red][0] (see Note5)
        XI_RGB_PLANAR = 4, // RGB planar data format. [Red][Red]...[Green][Green]...[Blue][Blue]... (see Note5)
        XI_RAW8 = 5,  // 8 bits per pixel raw data from sensor. 	[pixel byte] raw data from transport (camera output)
        XI_RAW16 = 6, // 16 bits per pixel raw data from sensor. 	[pixel byte low] [pixel byte high] 16 bits
                      // (depacked) raw data
        XI_FRM_TRANSPORT_DATA =
            7, // Data from transport layer (e.g. packed). Depends on data on the transport layer (see Note7)
        XI_RGB48 =
            8, // RGB data format. [Blue low byte][Blue high byte][Green low][Green high][Red low][Red high] (see Note5)
        XI_RGB64 = 9,         // RGBA data format. [Blue low byte][Blue high byte][Green low][Green high][Red low][Red
                              // high][0][0] (Note5)
        XI_RGB16_PLANAR = 10, // RGB16 planar data format
        XI_RAW8X2 = 11, // 8 bits per pixel raw data from sensor(2 components in a row). [ch1 pixel byte] [ch2 pixel
                        // byte] 8 bits raw data from 2 channels (e.g. high gain and low gain channels of sCMOS cameras)
        XI_RAW8X4 =
            12,          // 8 bits per pixel raw data from sensor(4 components in a row). 	[ch1 pixel byte [ch2 pixel
                         // byte] [ch3 pixel byte] [ch4 pixel byte] 8 bits raw data from 4 channels (e.g. sCMOS cameras)
        XI_RAW16X2 = 13, // 16 bits per pixel raw data from sensor(2 components in a row). 	[ch1 pixel byte low]
                         // [ch1 pixel byte high] [ch2 pixel byte low] [ch2 pixel byte high] 16 bits (depacked) raw data
                         // from 2 channels (e.g. high gain and low gain channels of sCMOS cameras)
        XI_RAW16X4 = 14, // 16 bits per pixel raw data from sensor(4 components in a row). 	[ch1 pixel byte low]
                         // [ch1 pixel byte high] [ch2 pixel byte low] [ch2 pixel byte high] [ch3 pixel byte low] [ch3
                         // pixel byte high] [ch4 pixel byte low] [ch4 pixel byte high] 16 bits (depacked) raw data from
                         // 4 channels (e.g. sCMOS cameras)
        XI_RAW32 = 15,      // 32 bits per pixel raw data from sensor in integer format (LSB first). 4 bytes (LSB first)
                            // pixel (depacked) raw data
        XI_RAW32FLOAT = 16, // 32 bits per pixel raw data from sensor in single-precision floating point format. 4 bytes
                            // per pixel (depacked) raw data

    } XI_IMG_FORMAT;

    // Bayer color matrix enumerator.
    typedef enum
    {
        XI_CFA_NONE = 0,               // Result pixels have no filters applied in this format
        XI_CFA_BAYER_RGGB = 1,         // Regular RGGB
        XI_CFA_CMYG = 2,               // AK Sony sens
        XI_CFA_RGR = 3,                // 2R+G readout
        XI_CFA_BAYER_BGGR = 4,         // BGGR readout
        XI_CFA_BAYER_GRBG = 5,         // GRBG readout
        XI_CFA_BAYER_GBRG = 6,         // GBRG readout
        XI_CFA_POLAR_A_BAYER_BGGR = 7, // BGGR polarized 4x4 macropixel
        XI_CFA_POLAR_A = 8,            // Polarized 2x2 macropixel

    } XI_COLOR_FILTER_ARRAY;

    // structure containing information about buffer policy(can be safe, data will be copied to user/app buffer or
    // unsafe, user will get internally allocated buffer without data copy).
    typedef enum
    {
        XI_BP_UNSAFE =
            0, // User gets pointer to internally allocated circle buffer and data may be overwritten by device.
        XI_BP_SAFE = 1, // Data from device will be copied to user allocated buffer or xiApi allocated memory.

    } XI_BP;

    // structure containing information about trigger source
    typedef enum
    {
        XI_TRG_OFF = 0,          // Capture of next image is automatically started after previous.
        XI_TRG_EDGE_RISING = 1,  // Capture is started on rising edge of selected input.
        XI_TRG_EDGE_FALLING = 2, // Capture is started on falling edge of selected input
        XI_TRG_SOFTWARE = 3,     // Capture is started with software trigger.
        XI_TRG_LEVEL_HIGH =
            4, // Specifies that the trigger is considered valid as long as the level of the source signal is high.
        XI_TRG_LEVEL_LOW =
            5, // Specifies that the trigger is considered valid as long as the level of the source signal is low.

    } XI_TRG_SOURCE;

    // structure containing information about trigger functionality
    typedef enum
    {
        XI_TRG_SEL_FRAME_START = 0,       // Trigger starts the capture of one frame
        XI_TRG_SEL_EXPOSURE_ACTIVE = 1,   // Trigger controls the start and length of the exposure.
        XI_TRG_SEL_FRAME_BURST_START = 2, // Trigger starts the capture of the bursts of frames in an acquisition.
        XI_TRG_SEL_FRAME_BURST_ACTIVE =
            3, // Trigger controls the duration of the capture of the bursts of frames in an acquisition.
        XI_TRG_SEL_MULTIPLE_EXPOSURES =
            4, // Trigger which when first trigger starts exposure and consequent pulses are gating exposure(active HI)
        XI_TRG_SEL_EXPOSURE_START = 5, // Trigger controls the start of the exposure of one Frame.
        XI_TRG_SEL_MULTI_SLOPE_PHASE_CHANGE =
            6, // Trigger controls the multi slope phase in one Frame (phase0 -> phase1) or (phase1 -> phase2).
        XI_TRG_SEL_ACQUISITION_START = 7, // Trigger starts acquisition of first frame.

    } XI_TRG_SELECTOR;

    // Trigger overlap modes
    typedef enum
    {
        XI_TRG_OVERLAP_OFF =
            0, // No trigger overlap is permitted. If camera is in read-out phase, all triggers are rejected.
        XI_TRG_OVERLAP_READ_OUT =
            1, // Trigger is accepted only when sensor is ready to start next exposure with defined exposure time.
               // Trigger is rejected when sensor is not ready for new exposure with defined exposure time. (see Note1)
        XI_TRG_OVERLAP_PREV_FRAME =
            2, // Trigger is accepted by camera any time. If sensor is not ready for the next exposure - the trigger is
               // latched and sensor starts exposure as soon as exposure can be started with defined exposure time.

    } XI_TRG_OVERLAP;

    // structure containing information about acquisition timing modes
    typedef enum
    {
        XI_ACQ_TIMING_MODE_FREE_RUN = 0, // camera acquires images at a maximum possible framerate
        XI_ACQ_TIMING_MODE_FRAME_RATE =
            1, // Selects a mode when sensor frame acquisition frequency is set to parameter FRAMERATE
        XI_ACQ_TIMING_MODE_FRAME_RATE_LIMIT =
            2, // Selects a mode when sensor frame acquisition frequency is limited by parameter FRAMERATE

    } XI_ACQ_TIMING_MODE;

    // Enumerator for data target modes
    typedef enum
    {
        XI_TRANSPORT_DATA_TARGET_CPU_RAM = 0,  // normal CPU memory buffer is used for image data
        XI_TRANSPORT_DATA_TARGET_GPU_RAM = 1,  // data is delivered straight to GPU memory using GPUDirect technology
        XI_TRANSPORT_DATA_TARGET_UNIFIED = 2,  // CUDA managed memory is used for image data.
        XI_TRANSPORT_DATA_TARGET_ZEROCOPY = 3, // CUDA zerocopy memory is used for image data.

    } XI_TRANSPORT_DATA_TARGET_MODE;

    // Enumeration for XI_PRM_GPI_SELECTOR for CB cameras.
    typedef enum
    {
        XI_GPI_SEL_CB_IN1 = 1,    // Input1 - Pin3 (Opto Isolated).
        XI_GPI_SEL_CB_IN2 = 2,    // Input2 - Pin4 (Opto Isolated).
        XI_GPI_SEL_CB_INOUT1 = 3, // Input/Output1 - Pin6
        XI_GPI_SEL_CB_INOUT2 = 4, // Input/Output2 - Pin7
        XI_GPI_SEL_CB_INOUT3 = 5, // Input/Output3 - Pin11
        XI_GPI_SEL_CB_INOUT4 = 6, // Input/Output4 - Pin12

    } XI_GPI_SEL_CB;

    // Enumeration for XI_PRM_GPO_SELECTOR for CB cameras.
    typedef enum
    {
        XI_GPO_SEL_CB_OUT1 = 1,   // Output1 - Pin8 (Opto Isolated).
        XI_GPO_SEL_CB_OUT2 = 2,   // Output2 - Pin9 (Opto Isolated).
        XI_GPO_SEL_CB_INOUT1 = 3, // Input/Output1 - Pin6
        XI_GPO_SEL_CB_INOUT2 = 4, // Input/Output2 - Pin7
        XI_GPO_SEL_CB_INOUT3 = 5, // Input/Output3 - Pin11
        XI_GPO_SEL_CB_INOUT4 = 6, // Input/Output4 - Pin12

    } XI_GPO_SEL_CB;

    // structure containing information about GPI functionality
    typedef enum
    {
        XI_GPI_OFF = 0,     // Input is not used for triggering, but can be used to get parameter GPI_LEVEL. This can be
                            // used to switch I/O line on some cameras to input mode.
        XI_GPI_TRIGGER = 1, // Input can be used for triggering
        XI_GPI_EXT_EVENT = 2, // External signal input (not implemented)

    } XI_GPI_MODE;

    // Enumerator for GPI port selection.
    typedef enum
    {
        XI_GPI_PORT1 = 1,   // GPI port 1
        XI_GPI_PORT2 = 2,   // GPI port 2
        XI_GPI_PORT3 = 3,   // GPI port 3
        XI_GPI_PORT4 = 4,   // GPI port 4
        XI_GPI_PORT5 = 5,   // GPI port 5
        XI_GPI_PORT6 = 6,   // GPI port 6
        XI_GPI_PORT7 = 7,   // GPI port 7
        XI_GPI_PORT8 = 8,   // GPI port 8
        XI_GPI_PORT9 = 9,   // GPI port 9
        XI_GPI_PORT10 = 10, // GPI port 10
        XI_GPI_PORT11 = 11, // GPI port 11
        XI_GPI_PORT12 = 12, // GPI port 12

    } XI_GPI_SELECTOR;

    // structure containing information about GPO functionality
    typedef enum
    {
        XI_GPO_OFF = 0,                    // Output is off (zero voltage or switched_off)
        XI_GPO_ON = 1,                     // Output is on (voltage or switched_on)
        XI_GPO_FRAME_ACTIVE = 2,           // Output is on while frame exposure,read,transfer.
        XI_GPO_FRAME_ACTIVE_NEG = 3,       // Output is off while frame exposure,read,transfer.
        XI_GPO_EXPOSURE_ACTIVE = 4,        // Output is on while frame exposure
        XI_GPO_EXPOSURE_ACTIVE_NEG = 5,    // Output is off while frame exposure
        XI_GPO_FRAME_TRIGGER_WAIT = 6,     // Output is on while camera is ready for trigger
        XI_GPO_FRAME_TRIGGER_WAIT_NEG = 7, // Output is off while camera is ready for trigger.
        XI_GPO_EXPOSURE_PULSE = 8,         // Output is on short pulse at the beginning of frame exposure.
        XI_GPO_EXPOSURE_PULSE_NEG = 9,     // Output is off short pulse at the beginning of frame exposure.
        XI_GPO_BUSY = 10,                  // Output is on when camera has received trigger until end of transfer
        XI_GPO_BUSY_NEG = 11,              // Output is off when camera has received trigger until end of transfer
        XI_GPO_HIGH_IMPEDANCE = 12, // Associated pin is in high impedance (tri-stated) and can be driven externally.
                                    // E.g. for triggering or reading status by GPI_LEVEL.
        XI_GPO_FRAME_BUFFER_OVERFLOW = 13,         // Frame buffer overflow status.
        XI_GPO_EXPOSURE_ACTIVE_FIRST_ROW = 14,     // Output is on while the first row exposure.
        XI_GPO_EXPOSURE_ACTIVE_FIRST_ROW_NEG = 15, // Output is off while the first row exposure.
        XI_GPO_EXPOSURE_ACTIVE_ALL_ROWS = 16,      // Output is on while all rows exposure together.
        XI_GPO_EXPOSURE_ACTIVE_ALL_ROWS_NEG = 17,  // Output is off while all rows exposure together.

    } XI_GPO_MODE;

    // Enumerator for GPO port selection.
    typedef enum
    {
        XI_GPO_PORT1 = 1,   // GPO port 1
        XI_GPO_PORT2 = 2,   // GPO port 2
        XI_GPO_PORT3 = 3,   // GPO port 3
        XI_GPO_PORT4 = 4,   // GPO port 4
        XI_GPO_PORT5 = 5,   // GPO port 5
        XI_GPO_PORT6 = 6,   // GPO port 6
        XI_GPO_PORT7 = 7,   // GPO port 7
        XI_GPO_PORT8 = 8,   // GPO port 8
        XI_GPO_PORT9 = 9,   // GPO port 9
        XI_GPO_PORT10 = 10, // GPO port 10
        XI_GPO_PORT11 = 11, // GPO port 11
        XI_GPO_PORT12 = 12, // GPO port 12

    } XI_GPO_SELECTOR;

    // structure containing information about LED functionality
    typedef enum
    {
        XI_LED_HEARTBEAT = 0,        // Set led to blink (1 Hz) if link is OK.
        XI_LED_TRIGGER_ACTIVE = 1,   // Set led to blink if trigger detected.
        XI_LED_EXT_EVENT_ACTIVE = 2, // Set led to blink if external signal detected.
        XI_LED_LINK = 3,             // Set led to blink if link is OK.
        XI_LED_ACQUISITION = 4,      // Set led to blink if data streaming
        XI_LED_EXPOSURE_ACTIVE = 5,  // Set led to blink if sensor integration time.
        XI_LED_FRAME_ACTIVE = 6,     // Set led to blink if device busy/not busy.
        XI_LED_OFF = 7,              // Set led to off.
        XI_LED_ON = 8,               // Set led to on.
        XI_LED_BLINK = 9,            // Blinking (1Hz).

    } XI_LED_MODE;

    // Enumerator for LED selection.
    typedef enum
    {
        XI_LED_SEL1 = 1, // LED 1
        XI_LED_SEL2 = 2, // LED 2
        XI_LED_SEL3 = 3, // LED 3
        XI_LED_SEL4 = 4, // LED 4
        XI_LED_SEL5 = 5, // LED 5

    } XI_LED_SELECTOR;

    // structure contains frames counter
    typedef enum
    {
        XI_CNT_SEL_TRANSPORT_SKIPPED_FRAMES =
            0, // Number of skipped frames on transport layer (e.g. when image gets lost while transmission). Occur when
               // capacity of transport channel does not allow to transfer all data.
        XI_CNT_SEL_API_SKIPPED_FRAMES = 1, // Number of skipped frames on API layer. Occur when application does not
                                           // process the images as quick as they are received from the camera.
        XI_CNT_SEL_TRANSPORT_TRANSFERRED_FRAMES = 2,       // Number of delivered buffers since last acquisition start.
        XI_CNT_SEL_FRAME_MISSED_TRIGGER_DUETO_OVERLAP = 3, // Number of missed triggers due to overlap.
        XI_CNT_SEL_FRAME_MISSED_TRIGGER_DUETO_FRAME_BUFFER_OVR =
            4,                                // Number of missed triggers due to frame buffer full.
        XI_CNT_SEL_FRAME_BUFFER_OVERFLOW = 5, // Frame buffer full counter.

    } XI_COUNTER_SELECTOR;

    // structure containing information about timestamp reset arming
    typedef enum
    {
        XI_TS_RST_ARM_ONCE = 0,    // Engine is disabled after TimeStamp has been reset after selected event.
        XI_TS_RST_ARM_PERSIST = 1, // Engine is armed permanently so each selected event will trigger TimeStamp reset.

    } XI_TS_RST_MODE;

    // structure containing information about possible timestamp reset sources
    typedef enum
    {
        XI_TS_RST_OFF = 0,              // No source selected TimeStamp reset is not armed.
        XI_TS_RST_SRC_GPI_1 = 1,        // GPI1 rising edge is active (signal after de-bounce module)
        XI_TS_RST_SRC_GPI_2 = 2,        // GPI2 rising edge is active
        XI_TS_RST_SRC_GPI_3 = 3,        // GPI3 rising edge is active
        XI_TS_RST_SRC_GPI_4 = 4,        // GPI4 rising edge is active
        XI_TS_RST_SRC_GPI_1_INV = 5,    // GPI1 falling edge is active
        XI_TS_RST_SRC_GPI_2_INV = 6,    // GPI2 falling edge is active
        XI_TS_RST_SRC_GPI_3_INV = 7,    // GPI3 falling edge is active
        XI_TS_RST_SRC_GPI_4_INV = 8,    // GPI4 falling edge is active
        XI_TS_RST_SRC_GPO_1 = 9,        // TimeStamp reset source selected GPO1
        XI_TS_RST_SRC_GPO_2 = 10,       // TimeStamp reset source selected GPO2
        XI_TS_RST_SRC_GPO_3 = 11,       // TimeStamp reset source selected GPO3
        XI_TS_RST_SRC_GPO_4 = 12,       // TimeStamp reset source selected GPO4
        XI_TS_RST_SRC_GPO_1_INV = 13,   // TimeStamp reset source selected GPO1 inverted
        XI_TS_RST_SRC_GPO_2_INV = 14,   // TimeStamp reset source selected GPO2 inverted
        XI_TS_RST_SRC_GPO_3_INV = 15,   // TimeStamp reset source selected GPO3 inverted
        XI_TS_RST_SRC_GPO_4_INV = 16,   // TimeStamp reset source selected GPO4 inverted
        XI_TS_RST_SRC_TRIGGER = 17,     // TRIGGER to sensor rising edge is active
        XI_TS_RST_SRC_TRIGGER_INV = 18, // TRIGGER to sensor rising edge is active
        XI_TS_RST_SRC_SW =
            19, // TRIGGER to sensor rising edge is active. TimeStamp is reset by software take effect imminently.
        XI_TS_RST_SRC_EXPACTIVE = 20,     // Exposure Active signal rising edge
        XI_TS_RST_SRC_EXPACTIVE_INV = 21, // Exposure Active signal falling edge
        XI_TS_RST_SRC_FVAL = 22,          // Frame valid signal rising edge (internal signal in camera)
        XI_TS_RST_SRC_FVAL_INV = 23,      // Frame valid signal falling edge (internal signal in camera)
        XI_TS_RST_SRC_GPI_5 = 24,         // GPI5 rising edge is active
        XI_TS_RST_SRC_GPI_6 = 25,         // GPI6 rising edge is active
        XI_TS_RST_SRC_GPI_5_INV = 26,     // GPI5 falling edge is active
        XI_TS_RST_SRC_GPI_6_INV = 27,     // GPI6 falling edge is active
        XI_TS_RST_SRC_GPI_7 = 28,         // TimeStamp reset source selected GPI7 (after de bounce)
        XI_TS_RST_SRC_GPI_8 = 29,         // TimeStamp reset source selected GPI8 (after de bounce)
        XI_TS_RST_SRC_GPI_9 = 30,         // TimeStamp reset source selected GPI9 (after de bounce)
        XI_TS_RST_SRC_GPI_10 = 31,        // TimeStamp reset source selected GPI10 (after de bounce)
        XI_TS_RST_SRC_GPI_11 = 32,        // TimeStamp reset source selected GPI11 (after de bounce)
        XI_TS_RST_SRC_GPI_7_INV = 33,     // TimeStamp reset source selected GPI7 inverted (after de bounce)
        XI_TS_RST_SRC_GPI_8_INV = 34,     // TimeStamp reset source selected GPI8 inverted (after de bounce)
        XI_TS_RST_SRC_GPI_9_INV = 35,     // TimeStamp reset source selected GPI9 inverted (after de bounce)
        XI_TS_RST_SRC_GPI_10_INV = 36,    // TimeStamp reset source selected GPI10 inverted (after de bounce)
        XI_TS_RST_SRC_GPI_11_INV = 37,    // TimeStamp reset source selected GPI11 inverted (after de bounce)

    } XI_TS_RST_SOURCE;

    // structure containing information about parameters type
    typedef enum
    {
        xiTypeInteger = 0,   // integer parameter type
        xiTypeFloat = 1,     // float parameter type
        xiTypeString = 2,    // string parameter type
        xiTypeEnum = 3,      // enumerator parameter type
        xiTypeBoolean = 4,   // boolean parameter type
        xiTypeCommand = 5,   // command parameter type
        xiTypeInteger64 = 6, // 64bit integer parameter type

    } XI_PRM_TYPE;

    // Turn parameter On/Off
    typedef enum
    {
        XI_OFF = 0, // Turn parameter off
        XI_ON = 1,  // Turn parameter on

    } XI_SWITCH;

    // Temperature selector
    typedef enum
    {
        XI_TEMP_IMAGE_SENSOR_DIE_RAW = 0, // Image sensor die (non-calibrated)
        XI_TEMP_IMAGE_SENSOR_DIE = 1,     // Image sensor die (calibrated)
        XI_TEMP_SENSOR_BOARD = 2,         // PCB as image sensor
        XI_TEMP_INTERFACE_BOARD = 3,      // Interface board
        XI_TEMP_FRONT_HOUSING = 4,        // Front part of camera housing
        XI_TEMP_REAR_HOUSING = 5,         // Rear part of camera housing
        XI_TEMP_TEC1_COLD = 6,            // TEC1 cold side temperature
        XI_TEMP_TEC1_HOT = 7,             // TEC1 hot side temperature

    } XI_TEMP_SELECTOR;

    // Temperature selector
    typedef enum
    {
        XI_TEMP_CTRL_MODE_OFF = 0,    // Controlling of elements (TEC/Peltier, Fans) is turned off
        XI_TEMP_CTRL_MODE_AUTO = 1,   // Controlling of elements is performed automatically by API or camera in order to
                                      // reach parameter TARGET_TEMP.
        XI_TEMP_CTRL_MODE_MANUAL = 2, // Controlling of elements is done manually by application.

    } XI_TEMP_CTRL_MODE_SELECTOR;

    // Temperature element selector
    typedef enum
    {
        XI_TEMP_ELEM_TEC1 = 11,           // TEC1 = TEC/Peltier that is closest to the image sensor
        XI_TEMP_ELEM_TEC2 = 12,           // TEC2 = TEC/Peltier location depends on camera model
        XI_TEMP_ELEM_FAN1 = 31,           // Temperature element fan current or rotation (FAN1 = Fan)
        XI_TEMP_ELEM_FAN1_THRS_TEMP = 32, // Temperature element fan start rotation threshold temperature

    } XI_TEMP_ELEMENT_SELECTOR;

    // Data packing(grouping) types.
    typedef enum
    {
        XI_DATA_PACK_XI_GROUPING = 0,      // Data grouping (10g160, 12g192, 14g224).
        XI_DATA_PACK_PFNC_LSB_PACKING = 1, // Data packing (10p, 12p)

    } XI_OUTPUT_DATA_PACKING_TYPE;

    // Downsampling types
    typedef enum
    {
        XI_BINNING = 0,  // pixels are interpolated - better image
        XI_SKIPPING = 1, // pixels are skipped - higher frame rate

    } XI_DOWNSAMPLING_TYPE;

    // Exposure time selector
    typedef enum
    {
        XI_EXPOSURE_TIME_SELECTOR_COMMON = 0, // Selects the common Exposure Time
        XI_EXPOSURE_TIME_SELECTOR_GROUP1 =
            1, // Selects the common Exposure Time for pixel group 1 (for InterlineExposureMode)
        XI_EXPOSURE_TIME_SELECTOR_GROUP2 =
            2, // Selects the common Exposure Time for pixel group 2 (for InterlineExposureMode)

    } XI_EXPOSURE_TIME_SELECTOR_TYPE;

    // Interline exposure mode
    typedef enum
    {
        XI_INTERLINE_EXPOSURE_MODE_OFF = 0, // Disabled
        XI_INTERLINE_EXPOSURE_MODE_ON = 1,  // Enabled

    } XI_INTERLINE_EXPOSURE_MODE_TYPE;

    // Gain selector
    typedef enum
    {
        XI_GAIN_SELECTOR_ALL = 0, // Gain selector selects all channels. Implementation of gain type depends on camera.
        XI_GAIN_SELECTOR_ANALOG_ALL =
            1, // Gain selector selects all analog channels. This is available only on some cameras.
        XI_GAIN_SELECTOR_DIGITAL_ALL =
            2, // Gain selector selects all digital channels. This is available only on some cameras.
        XI_GAIN_SELECTOR_ANALOG_TAP1 = 3, // Gain selector selects tap 1. This is available only on some cameras.
        XI_GAIN_SELECTOR_ANALOG_TAP2 = 4, // Gain selector selects tap 2. This is available only on some cameras.
        XI_GAIN_SELECTOR_ANALOG_TAP3 = 5, // Gain selector selects tap 3. This is available only on some cameras.
        XI_GAIN_SELECTOR_ANALOG_TAP4 = 6, // Gain selector selects tap 4. This is available only on some cameras.
        XI_GAIN_SELECTOR_ANALOG_N =
            7, // Gain selector selects North column analog gain. This is available only on some cameras.
        XI_GAIN_SELECTOR_ANALOG_S =
            8, // Gain selector selects South column analog gain. This is available only on some cameras.

    } XI_GAIN_SELECTOR_TYPE;

    // Shutter mode types
    typedef enum
    {
        XI_SHUTTER_GLOBAL = 0,               // Sensor Global Shutter(CMOS sensor)
        XI_SHUTTER_ROLLING = 1,              // Sensor Electronic Rolling Shutter(CMOS sensor)
        XI_SHUTTER_GLOBAL_RESET_RELEASE = 2, // Sensor Global Reset Release Shutter(CMOS sensor)

    } XI_SHUTTER_TYPE;

    // structure containing information about CMS functionality
    typedef enum
    {
        XI_CMS_DIS = 0,     // disables color management
        XI_CMS_EN = 1,      // enables color management (high CPU usage)
        XI_CMS_EN_FAST = 2, // enables fast color management (high RAM usage)

    } XI_CMS_MODE;

    // structure containing information about ICC Intents
    typedef enum
    {
        XI_CMS_INTENT_PERCEPTUAL = 0,            // CMS intent perceptual
        XI_CMS_INTENT_RELATIVE_COLORIMETRIC = 1, // CMS intent relative colorimetry
        XI_CMS_INTENT_SATURATION = 2,            // CMS intent saturation
        XI_CMS_INTENT_ABSOLUTE_COLORIMETRIC = 3, // CMS intent absolute colorimetry

    } XI_CMS_INTENT;

    // structure containing information about options for selection of camera before opening
    typedef enum
    {
        XI_OPEN_BY_INST_PATH = 0, // Open camera by its hardware path
        XI_OPEN_BY_SN = 1,        // Open camera by its serial number
        XI_OPEN_BY_USER_ID = 2,   // open camera by its custom user ID
        XI_OPEN_BY_LOC_PATH = 3,  // Open camera by its hardware location path

    } XI_OPEN_BY;

    // Lens feature selector selects which feature will be accessed.
    typedef enum
    {
        XI_LENS_FEATURE_MOTORIZED_FOCUS_SWITCH = 1,  // Status of lens motorized focus switch
        XI_LENS_FEATURE_MOTORIZED_FOCUS_BOUNDED = 2, // On read = 1 if motorized focus is on one of limits.
        XI_LENS_FEATURE_MOTORIZED_FOCUS_CALIBRATION =
            3, // On read = 1 if motorized focus is calibrated. Write 1 to start calibration.
        XI_LENS_FEATURE_IMAGE_STABILIZATION_ENABLED =
            4, // On read = 1 if image stabilization is enabled. Write 1 to enable image stabilization.
        XI_LENS_FEATURE_IMAGE_STABILIZATION_SWITCH_STATUS =
            5,                                    // On read = 1 if image stabilization switch is in position On.
        XI_LENS_FEATURE_IMAGE_ZOOM_SUPPORTED = 6, // On read = 1 if lens supports zoom = are not prime.

    } XI_LENS_FEATURE;

    // Sensor feature selector selects which feature will be accessed.
    typedef enum
    {
        XI_SENSOR_FEATURE_ZEROROT_ENABLE = 0, // Zero ROT enable for ONSEMI PYTHON family. For camera model:MQ013xG-ON
        XI_SENSOR_FEATURE_BLACK_LEVEL_CLAMP = 1,            // Black level offset clamping. for Camera model:MD
        XI_SENSOR_FEATURE_MD_FPGA_DIGITAL_GAIN_DISABLE = 2, // Disable digital component of gain for MD family
        XI_SENSOR_FEATURE_ACQUISITION_RUNNING =
            3, // Sensor acquisition is running status. Could be stopped by setting of 0. For camera model:CB,MC,MX,MT
        XI_SENSOR_FEATURE_TIMING_MODE = 4,  // Set Sensor timing mode
        XI_SENSOR_FEATURE_PARALLEL_ADC = 5, // Parallel ADC readout

    } XI_SENSOR_FEATURE_SELECTOR;

    // Camera sensor mode enumerator.
    typedef enum
    {
        XI_SENS_MD0 = 0,   // Sensor mode number 0
        XI_SENS_MD1 = 1,   // Sensor mode number 1
        XI_SENS_MD2 = 2,   // Sensor mode number 2
        XI_SENS_MD3 = 3,   // Sensor mode number 3
        XI_SENS_MD4 = 4,   // Sensor mode number 4
        XI_SENS_MD5 = 5,   // Sensor mode number 5
        XI_SENS_MD6 = 6,   // Sensor mode number 6
        XI_SENS_MD7 = 7,   // Sensor mode number 7
        XI_SENS_MD8 = 8,   // Sensor mode number 8
        XI_SENS_MD9 = 9,   // Sensor mode number 9
        XI_SENS_MD10 = 10, // Sensor mode number 10
        XI_SENS_MD11 = 11, // Sensor mode number 11
        XI_SENS_MD12 = 12, // Sensor mode number 12
        XI_SENS_MD13 = 13, // Sensor mode number 13
        XI_SENS_MD14 = 14, // Sensor mode number 14
        XI_SENS_MD15 = 15, // Sensor mode number 15

    } XI_SENSOR_MODE;

    // Camera channel count enumerator.
    typedef enum
    {
        XI_CHANN_CNT2 = 2,   // 2 sensor readout channels.
        XI_CHANN_CNT4 = 4,   // 4 sensor readout channels.
        XI_CHANN_CNT8 = 8,   // 8 sensor readout channels.
        XI_CHANN_CNT16 = 16, // 16 sensor readout channels.
        XI_CHANN_CNT32 = 32, // 32 sensor readout channels.

    } XI_SENSOR_OUTPUT_CHANNEL_COUNT;

    // Sensor defects correction list selector
    typedef enum
    {
        XI_SENS_DEFFECTS_CORR_LIST_SEL_FACTORY = 0, // Factory defect correction list
        XI_SENS_DEFFECTS_CORR_LIST_SEL_USER0 = 1,   // User defect correction list

    } XI_SENS_DEFFECTS_CORR_LIST_SELECTOR;

    // Acquisition status Selector
    typedef enum
    {
        XI_ACQUISITION_STATUS_ACQ_ACTIVE = 0, //  Device is currently doing an acquisition of one or many frames.

    } XI_ACQUISITION_STATUS_SELECTOR;

    // Select unit where data-pipe is configured
    typedef enum
    {
        XI_DP_UNIT_SENSOR = 0, // Selects device image sensor
        XI_DP_UNIT_FPGA = 1,   // Selects device image FPGA

    } XI_DP_UNIT_SELECTOR;

    // Select unit processor
    typedef enum
    {
        XI_DP_PROC_NONE = 0,            // Default empty processor
        XI_DP_PROC_CHANNEL_MUXER = 1,   // Channel Muxer (selected processor combines multiple input channels)
        XI_DP_PROC_PIXEL_SEQUENCER = 2, // Selects pixel data output sequence
        XI_DP_PROC_CHANNEL_1 = 3,       // Selects sensor output channel 1
        XI_DP_PROC_CHANNEL_2 = 4,       // Selects sensor output channel 2
        XI_DP_PROC_FRAME_BUFFER = 5,    // Selects frame buffer memory

    } XI_DP_PROC_SELECTOR;

    // Select processor parameter
    typedef enum
    {
        XI_DP_PARAM_NONE = 0,                   // Empty parameter
        XI_DP_PARAM_CHMUX_CHANNEL_SELECTOR = 1, // Defines output of Channel Muxer processor
        XI_DP_PARAM_CHMUX_ALPHA = 2,            // Channel merger coefficient Alpha
        XI_DP_PARAM_CHMUX_BETA = 3,             // Channel merger coefficient Beta
        XI_DP_PARAM_PIXSEQ_SELECTOR = 4,        // PixSeq Selector
        XI_DP_PARAM_CHANNEL_TIMING = 5,         // Selected channel timing
        XI_DP_PARAM_FRAMEBUF_MODE = 6,          // Frame Buffer Mode
        XI_DP_PARAM_FRAMEBUF_SIZE = 7,          // Frame Buffer Size Bytes

    } XI_DP_PARAM_SELECTOR;

    // Select processor parameter value
    typedef enum
    {
        XI_DP_PARAM_VALUE_CHMUX_CHANNEL_1 = 0,        // Selected source channel 1
        XI_DP_PARAM_VALUE_CHMUX_CHANNEL_2 = 1,        // Selected source channel 2
        XI_DP_PARAM_VALUE_CHMUX_CHANNEL_1_2 = 2,      // Selected source channel 1 and 2
        XI_DP_PARAM_VALUE_CHMUX_MERGED = 3,           // Merged data of two channels
        XI_DP_PARAM_VALUE_CHMUX_CMS = 4,              // Correlated Multiple Sampling
        XI_DP_PARAM_VALUE_PIXSEQ_ONE_VALUE = 5,       // Output is one value per pixel
        XI_DP_PARAM_VALUE_PIXSEQ_TWO_VALUES = 6,      // Output are two values per pixel
        XI_DP_PARAM_VALUE_CHTIM_HG = 7,               // High Gain channel timing
        XI_DP_PARAM_VALUE_CHTIM_LG = 8,               // Low Gain channel timing
        XI_DP_PARAM_VALUE_FRAMEBUF_MODE_DISABLED = 9, // Frame buffer is disabled
        XI_DP_PARAM_VALUE_FRAMEBUF_MODE_ENABLED = 10, // Frame buffer is on
        XI_DP_PARAM_VALUE_PIXSEQ_FOUR_VALUES = 11,    // Output are four values per pixel

    } XI_DP_PARAM_VALUE;

    // User Set selector options.
    typedef enum
    {
        XI_US_DEFAULT = 0,          // Default factory preset.
        XI_US_USERSET1 = 1,         // User Set 1 created by user.
        XI_US_12_STD_L = 10,        // 12bit per channel STD Low Gain mode preset.
        XI_US_12_STD_H = 11,        // 12bit per channel STD High Gain mode preset.
        XI_US_14_STD_L = 12,        // 14bit per channel STD Low Gain mode preset.
        XI_US_14_STD_H = 13,        // 14bit per channel STD High Gain mode preset.
        XI_US_2_12_CMS_L = 14,      // 12bit per channel, 2 samples,  CMS Low Gain mode preset.
        XI_US_2_12_CMS_H = 15,      // 12bit per channel, 2 samples,  CMS High Gain mode preset.
        XI_US_2_14_CMS_L = 16,      // 14bit per channel, 2 samples,  CMS Low Gain mode preset.
        XI_US_2_14_CMS_H = 17,      // 14bit per channel, 2 samples,  CMS High Gain mode preset.
        XI_US_4_12_CMS_L = 18,      // 12bit per channel, 4 samples,  CMS Low Gain mode preset.
        XI_US_4_12_CMS_H = 19,      // 12bit per channel, 4 samples,  CMS High Gain mode preset.
        XI_US_4_14_CMS_L = 20,      // 114bit per channel, 4 samples,  CMS Low Gain mode preset.
        XI_US_4_14_CMS_H = 21,      // 14bit per channel, 4 samples,  CMS High Gain mode preset.
        XI_US_2_12_HDR_HL = 22,     // 12bit per channel, 2 samples,  HDR High Low Gain mode preset.
        XI_US_2_12_HDR_L = 23,      // 12bit per channel, 2 samples,  HDR Low Gain mode preset.
        XI_US_2_12_HDR_H = 24,      // 12bit per channel, 2 samples,  HDR High Gain mode preset.
        XI_US_4_12_CMS_HDR_HL = 25, // 12bit per channel, 4 samples,  CMS + HDR High Low Gain mode preset.

    } XI_USER_SET_SELECTOR;

    typedef enum
    {
        XI_GenTL_Image_Format_Mono8 = 0x01080001,      // This enumeration value sets the pixel format to Mono 8.
        XI_GenTL_Image_Format_BGRA8 = 0x02200017,      // This enumeration value sets the pixel format to Bayer BG 8
        XI_GenTL_Image_Format_RGB8Planar = 0x02180021, // This enumeration value sets the pixel format to RGB 8 Planar.
        XI_GenTL_Image_Format_BayerRG8 = 0x01080009,   // Pixel format 'Bayer RG 8'.
        XI_GenTL_Image_Format_Mono10 = 0x01100003,     // Pixel format 'Mono10'
        XI_GenTL_Image_Format_Mono12 = 0x01100005,     // Pixel format 'Mono 12'
        XI_GenTL_Image_Format_Mono14 = 0x01100025,     // Pixel format 'Mono 14'
        XI_GenTL_Image_Format_BayerRG10 = 0x0110000D,  // Pixel format 'Bayer RG 10'
        XI_GenTL_Image_Format_BayerRG12 = 0x01100011,  // Pixel format 'Bayer RG 12'
        XI_GenTL_Image_Format_BayerGR8 = 0x01080008,   // Pixel format 'Bayer GR 8'
        XI_GenTL_Image_Format_BayerGB8 = 0x0108000A,   // Pixel format 'Bayer GB 8'
        XI_GenTL_Image_Format_BayerGR10 = 0x0110000C,  // Pixel format 'Bayer GR 10'
        XI_GenTL_Image_Format_BayerGB10 = 0x0110000E,  // Pixel format 'Bayer GB 10'
        XI_GenTL_Image_Format_BayerGR12 = 0x01100010,  // Pixel format ''Bayer GR 12
        XI_GenTL_Image_Format_BayerBG8 = 0x0108000B,   // Pixel format 'Bayer BG 8'
        XI_GenTL_Image_Format_BayerBG10 = 0x0110000F,  // Pixel format 'Bayer BG 10'
        XI_GenTL_Image_Format_BayerBG12 = 0x01100013,  // Pixel format
        XI_GenTL_Image_Format_BayerGB12 = 0x01100012,  // Pixel format
        XI_GenTL_Image_Format_RGB8 = 0x02180014,       // This enumeration value sets the pixel format to R8,G8,B8
        XI_GenTL_Image_Format_BGR8 = 0x02180015,       // This enumeration value sets the pixel format to B8,G8,R8
        XI_GenTL_Image_Format_BayerRG14 = 0x0110010A,  // Pixel format one 14 bit pixel in 2 bytes
        XI_GenTL_Image_Format_BayerGR14 = 0x01100109,  // Pixel format one 14 bit pixel in 2 bytes
        XI_GenTL_Image_Format_BayerBG14 = 0x0110010C,  // Pixel format one 14 bit pixel in 2 bytes
        XI_GenTL_Image_Format_BayerGB14 = 0x0110010B,  // Pixel format one 14 bit pixel in 2 bytes
        XI_GenTL_Image_Format_BayerBG10p = 0x010A0052, // Pixel format 10bit packed (4 pixels in 5 bytes)
        XI_GenTL_Image_Format_BayerGB10p = 0x010A0054, // Pixel format 10bit packed (4 pixels in 5 bytes)
        XI_GenTL_Image_Format_BayerGR10p = 0x010A0056, // Pixel format 10bit packed (4 pixels in 5 bytes)
        XI_GenTL_Image_Format_BayerRG10p = 0x010A0058, // Pixel format 10bit packed (4 pixels in 5 bytes)
        XI_GenTL_Image_Format_Mono10p = 0x010a0046,    // Pixel format 10bit packed (4 pixels in 5 bytes)
        XI_GenTL_Image_Format_BayerBG12p = 0x010C0053, // Pixel format 12bit packed (2 pixels in 3 bytes)
        XI_GenTL_Image_Format_BayerGB12p = 0x010C0055, // Pixel format 12bit packed (2 pixels in 3 bytes)
        XI_GenTL_Image_Format_BayerGR12p = 0x010C0057, // Pixel format 12bit packed (2 pixels in 3 bytes)
        XI_GenTL_Image_Format_BayerRG12p = 0x010C0059, // Pixel format 12bit packed (2 pixels in 3 bytes)
        XI_GenTL_Image_Format_Mono12p = 0x010c0047,    // Pixel format 12bit packed (2 pixels in 3 bytes)
        XI_GenTL_Image_Format_BayerBG14p = 0x010E0108, // Pixel format 14bit packed (4 pixels in 7 bytes)
        XI_GenTL_Image_Format_BayerGB14p = 0x010E0107, // Pixel format 14bit packed (4 pixels in 7 bytes)
        XI_GenTL_Image_Format_BayerGR14p = 0x010E0105, // Pixel format 14bit packed (4 pixels in 7 bytes)
        XI_GenTL_Image_Format_BayerRG14p = 0x010E0106, // Pixel format 14bit packed (4 pixels in 7 bytes)
        XI_GenTL_Image_Format_Mono14p = 0x010E0104,    // Pixel format 14bit packed (4 pixels in 7 bytes)
        XI_GenTL_Image_Format_xiBayerBG10g160 = 0x8200010A,   // Pixel format 10bit (16 pixels in 20 bytes)
        XI_GenTL_Image_Format_xiBayerGB10g160 = 0x8200020A,   // Pixel format 10bit (16 pixels in 20 bytes)
        XI_GenTL_Image_Format_xiBayerGR10g160 = 0x8200030A,   // Pixel format 10bit (16 pixels in 20 bytes)
        XI_GenTL_Image_Format_xiBayerRG10g160 = 0x8200040A,   // Pixel format 10bit (16 pixels in 20 bytes)
        XI_GenTL_Image_Format_xiMono10g160 = 0x8200000A,      // Pixel format 10bit (16 pixels in 20 bytes)
        XI_GenTL_Image_Format_xiBayerBG12g192 = 0x8200010C,   // Pixel format 12bit (16 pixels in 24 bytes)
        XI_GenTL_Image_Format_xiBayerGB12g192 = 0x8200020C,   // Pixel format 12bit (16 pixels in 24 bytes)
        XI_GenTL_Image_Format_xiBayerGR12g192 = 0x8200030C,   // Pixel format 12bit (16 pixels in 24 bytes)
        XI_GenTL_Image_Format_xiBayerRG12g192 = 0x8200040C,   // Pixel format 12bit (16 pixels in 24 bytes)
        XI_GenTL_Image_Format_xiMono12g192 = 0x8200000C,      // Pixel format 12bit (16 pixels in 24 bytes)
        XI_GenTL_Image_Format_xiBayerBG14g224 = 0x8200010E,   // Pixel format 14bit (16 pixels in 28 bytes)
        XI_GenTL_Image_Format_xiBayerGB14g224 = 0x8200020E,   // Pixel format 14bit (16 pixels in 28 bytes)
        XI_GenTL_Image_Format_xiBayerGR14g224 = 0x8200030E,   // Pixel format 14bit (16 pixels in 28 bytes)
        XI_GenTL_Image_Format_xiBayerRG14g224 = 0x8200040E,   // Pixel format 14bit (16 pixels in 28 bytes)
        XI_GenTL_Image_Format_xiMono14g224 = 0x8200000E,      // Pixel format 14bit (16 pixels in 28 bytes)
        XI_GenTL_Image_Format_xiMono8TS01 = 0x80010008,       // Pixel format 8bit(2 taps)
        XI_GenTL_Image_Format_xiMono10TS01 = 0x8001000A,      // Pixel format 10bit(2 taps)
        XI_GenTL_Image_Format_xiMono12TS01 = 0x8001000C,      // Pixel format 12bit(2 taps)
        XI_GenTL_Image_Format_xiMono14TS01 = 0x8001000E,      // Pixel format 14bit(2 taps)
        XI_GenTL_Image_Format_xiBayerRG8TS01 = 0x80010408,    // Pixel format (2 taps)
        XI_GenTL_Image_Format_xiBayerRG10TS01 = 0x8001040A,   // Pixel format 10 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerRG12TS01 = 0x8001040C,   // Pixel format 12 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerRG14TS01 = 0x8001040E,   // Pixel format 14 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerBG8TS01 = 0x80010108,    // Pixel format (2 taps)
        XI_GenTL_Image_Format_xiBayerBG10TS01 = 0x8001010A,   // Pixel format 10 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerBG12TS01 = 0x8001010C,   // Pixel format 12 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerBG14TS01 = 0x8001010E,   // Pixel format 14 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerGB8TS01 = 0x80010208,    // Pixel format (2 taps)
        XI_GenTL_Image_Format_xiBayerGB10TS01 = 0x8001020A,   // Pixel format 10 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerGB12TS01 = 0x8001020C,   // Pixel format 12 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerGB14TS01 = 0x8001020E,   // Pixel format 14 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerGR8TS01 = 0x80010308,    // Pixel format (2 taps)
        XI_GenTL_Image_Format_xiBayerGR10TS01 = 0x8001030A,   // Pixel format 10 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerGR12TS01 = 0x8001030C,   // Pixel format 12 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerGR14TS01 = 0x8001030E,   // Pixel format 14 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiMono8TS03 = 0x80030008,       // Pixel format 8bit(4 taps)
        XI_GenTL_Image_Format_xiMono10TS03 = 0x8003000A,      // Pixel format 10bit(4 taps)
        XI_GenTL_Image_Format_xiMono12TS03 = 0x8003000C,      // Pixel format 12bit(4 taps)
        XI_GenTL_Image_Format_xiMono14TS03 = 0x8003000E,      // Pixel format 14bit(4 taps)
        XI_GenTL_Image_Format_xiBayerRG8TS03 = 0x80030408,    // Pixel format (4 taps)
        XI_GenTL_Image_Format_xiBayerRG10TS03 = 0x8003040A,   // Pixel format 10 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerRG12TS03 = 0x8003040C,   // Pixel format 12 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerRG14TS03 = 0x8003040E,   // Pixel format 14 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerBG8TS03 = 0x80030108,    // Pixel format (4 taps)
        XI_GenTL_Image_Format_xiBayerBG10TS03 = 0x8003010A,   // Pixel format 10 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerBG12TS03 = 0x8003010C,   // Pixel format 12 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerBG14TS03 = 0x8003010E,   // Pixel format 14 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerGB8TS03 = 0x80030208,    // Pixel format (4 taps)
        XI_GenTL_Image_Format_xiBayerGB10TS03 = 0x8003020A,   // Pixel format 10 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerGB12TS03 = 0x8003020C,   // Pixel format 12 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerGB14TS03 = 0x8003020E,   // Pixel format 14 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerGR8TS03 = 0x80030308,    // Pixel format (4 taps)
        XI_GenTL_Image_Format_xiBayerGR10TS03 = 0x8003030A,   // Pixel format 10 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerGR12TS03 = 0x8003030C,   // Pixel format 12 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerGR14TS03 = 0x8003030E,   // Pixel format 14 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_Mono16 = 0x01100007,            // Pixel format 16 monochrome
        XI_GenTL_Image_Format_BayerGR16 = 0x0110002E,         // Pixel format Bayer GR 16
        XI_GenTL_Image_Format_BayerRG16 = 0x0110002F,         // Pixel format Bayer RG 16
        XI_GenTL_Image_Format_BayerGB16 = 0x01100030,         // Pixel format Bayer GB 16
        XI_GenTL_Image_Format_BayerBG16 = 0x01100031,         // Pixel format Bayer BG 16
        XI_GenTL_Image_Format_xiMono16TS03 = 0x80030010,      // Pixel format 16bit(4 taps)
        XI_GenTL_Image_Format_xiMono16TS01 = 0x80010010,      // Pixel format 16bit(2 taps)
        XI_GenTL_Image_Format_xiBayerRG16TS01 = 0x80010410,   // Pixel format 16 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerBG16TS01 = 0x80010110,   // Pixel format 16 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerGB16TS01 = 0x80010210,   // Pixel format 16 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerGR16TS01 = 0x80010310,   // Pixel format 16 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerRG16TS03 = 0x80030410,   // Pixel format 16 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerBG16TS03 = 0x80030110,   // Pixel format 16 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerGB16TS03 = 0x80030210,   // Pixel format 16 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerGR16TS03 = 0x80030310,   // Pixel format 16 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiMono16TS04 = 0x80040010,      // Pixel format 16bit(4 taps)
        XI_GenTL_Image_Format_xiBayerRG16TS04 = 0x80040410,   // Pixel format 16 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerBG16TS04 = 0x80040110,   // Pixel format 16 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerGB16TS04 = 0x80040210,   // Pixel format 16 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerGR16TS04 = 0x80040310,   // Pixel format 16 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiMono16TS02 = 0x80020010,      // Pixel format 16bit(2 taps)
        XI_GenTL_Image_Format_xiMono8TS02 = 0x80020008,       // Pixel format 8bit(2 taps)
        XI_GenTL_Image_Format_xiMono10TS02 = 0x8002000A,      // Pixel format 10bit(2 taps)
        XI_GenTL_Image_Format_xiMono12TS02 = 0x8002000C,      // Pixel format 12bit(2 taps)
        XI_GenTL_Image_Format_xiMono14TS02 = 0x8002000E,      // Pixel format 14bit(2 taps)
        XI_GenTL_Image_Format_xiBayerRG8TS02 = 0x80020408,    // Pixel format (2 taps)
        XI_GenTL_Image_Format_xiBayerRG10TS02 = 0x8002040A,   // Pixel format 10 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerRG12TS02 = 0x8002040C,   // Pixel format 12 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerRG14TS02 = 0x8002040E,   // Pixel format 14 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerRG16TS02 = 0x80020410,   // Pixel format 16 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerBG8TS02 = 0x80020108,    // Pixel format (2 taps)
        XI_GenTL_Image_Format_xiBayerBG10TS02 = 0x8002010A,   // Pixel format 10 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerBG12TS02 = 0x8002010C,   // Pixel format 12 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerBG14TS02 = 0x8002010E,   // Pixel format 14 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerBG16TS02 = 0x80020110,   // Pixel format 16 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerGB8TS02 = 0x80020208,    // Pixel format (2 taps)
        XI_GenTL_Image_Format_xiBayerGB10TS02 = 0x8002020A,   // Pixel format 10 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerGB12TS02 = 0x8002020C,   // Pixel format 12 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerGB14TS02 = 0x8002020E,   // Pixel format 14 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerGB16TS02 = 0x80020210,   // Pixel format 16 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerGR8TS02 = 0x80020308,    // Pixel format (2 taps)
        XI_GenTL_Image_Format_xiBayerGR10TS02 = 0x8002030A,   // Pixel format 10 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerGR12TS02 = 0x8002030C,   // Pixel format 12 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerGR14TS02 = 0x8002030E,   // Pixel format 14 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiBayerGR16TS02 = 0x80020310,   // Pixel format 16 bits in 2 bytes(2 taps)
        XI_GenTL_Image_Format_xiMono8TS04 = 0x80040008,       // Pixel format 8bit(4 taps)
        XI_GenTL_Image_Format_xiMono10TS04 = 0x8004000A,      // Pixel format 10bit(4 taps)
        XI_GenTL_Image_Format_xiMono12TS04 = 0x8004000C,      // Pixel format 12bit(4 taps)
        XI_GenTL_Image_Format_xiMono14TS04 = 0x8004000E,      // Pixel format 14bit(4 taps)
        XI_GenTL_Image_Format_xiBayerRG8TS04 = 0x80040408,    // Pixel format (4 taps)
        XI_GenTL_Image_Format_xiBayerRG10TS04 = 0x8004040A,   // Pixel format 10 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerRG12TS04 = 0x8004040C,   // Pixel format 12 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerRG14TS04 = 0x8004040E,   // Pixel format 14 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerBG8TS04 = 0x80040108,    // Pixel format (4 taps)
        XI_GenTL_Image_Format_xiBayerBG10TS04 = 0x8004010A,   // Pixel format 10 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerBG12TS04 = 0x8004010C,   // Pixel format 12 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerBG14TS04 = 0x8004010E,   // Pixel format 14 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerGB8TS04 = 0x80040208,    // Pixel format (4 taps)
        XI_GenTL_Image_Format_xiBayerGB10TS04 = 0x8004020A,   // Pixel format 10 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerGB12TS04 = 0x8004020C,   // Pixel format 12 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerGB14TS04 = 0x8004020E,   // Pixel format 14 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerGR8TS04 = 0x80040308,    // Pixel format (4 taps)
        XI_GenTL_Image_Format_xiBayerGR10TS04 = 0x8004030A,   // Pixel format 10 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerGR12TS04 = 0x8004030C,   // Pixel format 12 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_xiBayerGR14TS04 = 0x8004030E,   // Pixel format 14 bits in 2 bytes(4 taps)
        XI_GenTL_Image_Format_Mono9p = 0x81000009,            // Pixel format 9bit packed (8 pixels in 9 bytes)
        XI_GenTL_Image_Format_BayerBG9p = 0x81000109,         // Pixel format 9bit packed (8 pixels in 9 bytes)
        XI_GenTL_Image_Format_BayerGB9p = 0x81000209,         // Pixel format 9bit packed (8 pixels in 9 bytes)
        XI_GenTL_Image_Format_BayerGR9p = 0x81000309,         // Pixel format 9bit packed (8 pixels in 9 bytes)
        XI_GenTL_Image_Format_BayerRG9p = 0x81000409,         // Pixel format 9bit packed (8 pixels in 9 bytes)
        XI_GenTL_Image_Format_Mono11p = 0x8100000B,           // Pixel format 11bit packed (8 pixels in 11 bytes)
        XI_GenTL_Image_Format_BayerBG11p = 0x8100010B,        // Pixel format 11bit packed (8 pixels in 11 bytes)
        XI_GenTL_Image_Format_BayerGB11p = 0x8100020B,        // Pixel format 11bit packed (8 pixels in 11 bytes)
        XI_GenTL_Image_Format_BayerGR11p = 0x8100030B,        // Pixel format 11bit packed (8 pixels in 11 bytes)
        XI_GenTL_Image_Format_BayerRG11p = 0x8100040B,        // Pixel format 11bit packed (8 pixels in 11 bytes)
        XI_GenTL_Image_Format_Mono9 = 0x80000009,             // Pixel format 9bit
        XI_GenTL_Image_Format_BayerBG9 = 0x80000109,          // Pixel format 9bit
        XI_GenTL_Image_Format_BayerGB9 = 0x80000209,          // Pixel format 9bit
        XI_GenTL_Image_Format_BayerGR9 = 0x80000309,          // Pixel format 9bit
        XI_GenTL_Image_Format_BayerRG9 = 0x80000409,          // Pixel format 9bit
        XI_GenTL_Image_Format_Mono11 = 0x8000000B,            // Pixel format 11bit
        XI_GenTL_Image_Format_BayerBG11 = 0x8000010B,         // Pixel format 11bit
        XI_GenTL_Image_Format_BayerGB11 = 0x8000020B,         // Pixel format 11bit
        XI_GenTL_Image_Format_BayerGR11 = 0x8000030B,         // Pixel format 11bit
        XI_GenTL_Image_Format_BayerRG11 = 0x8000040B,         // Pixel format 11bit
        XI_GenTL_Image_Format_xiMono12g96l_m9e3 = 0x8300100C, // Pixel format 12bit
        XI_GenTL_Image_Format_xiBayerGB12pMS41 = 0x8141020C,  // Pixel format 12bit
        XI_GenTL_Image_Format_xiMono12pMS41 = 0x8141000C,     // Pixel format 12bit
        XI_GenTL_Image_Format_xiBayerGB10pMS41 = 0x8141020A,  // Pixel format 10bit
        XI_GenTL_Image_Format_xiBayerGB12MS41 = 0x8041020C,   // Pixel format 12bit
        XI_GenTL_Image_Format_xiBayerGB10MS41 = 0x8041020A,   // Pixel format 10bit
        XI_GenTL_Image_Format_xiMono10pMS51 = 0x8151000A,     // Pixel format 10bit
        XI_GenTL_Image_Format_xiMono10pMS41 = 0x8141000A,     // Pixel format 10bit
        XI_GenTL_Image_Format_xiBayerGB10pMS51 = 0x8151020A,  // Pixel format 10bit
        XI_GenTL_Image_Format_xiMono12MS41 = 0x8041000C,      // Pixel format 12bit
        XI_GenTL_Image_Format_xiMono10MS51 = 0x8051000A,      // Pixel format 10bit
        XI_GenTL_Image_Format_xiMono10MS41 = 0x8041000A,      // Pixel format 10bit
        XI_GenTL_Image_Format_xiBayerGB10MS51 = 0x8051020A,   // Pixel format 10bit
        XI_GenTL_Image_Format_xiBayerGB8MS41 = 0x80410208,    // Pixel format 8bit
        XI_GenTL_Image_Format_xiMono8MS51 = 0x80510008,       // Pixel format 8bit
        XI_GenTL_Image_Format_xiMono8MS41 = 0x80410008,       // Pixel format 8bit
        XI_GenTL_Image_Format_xiBayerGB8MS51 = 0x80510208,    // Pixel format 8bit
        XI_GenTL_Image_Format_xiMono_m9e3 = 0x80001010,       // Pixel format 16bit
        XI_GenTL_Image_Format_RGBA8 = 0x02200016, // This enumeration value sets the pixel format to Bayer RG 8
        XI_GenTL_Image_Format_RGB16Planar =
            0x02300024,                            // This enumeration value sets the pixel format to RGB 16 Planar.
        XI_GenTL_Image_Format_BGRA16 = 0x02400051, // This enumeration value sets the pixel format to Bayer BG 16
        XI_GenTL_Image_Format_BGR16 = 0x0230004B,  // This enumeration value sets the pixel format to Bayer BG 16
        XI_GenTL_Image_Format_RGBA16 = 0x02400064, // This enumeration value sets the pixel format to Bayer RG 16
        XI_GenTL_Image_Format_RGB16 = 0x02300033,  // This enumeration value sets the pixel format to Bayer RG 16
        XI_GenTL_Image_Format_xiMono8MS52 = 0x80520008,      // Pixel format 8bit
        XI_GenTL_Image_Format_xiMono10pMS52 = 0x8152000A,    // Pixel format 10bit
        XI_GenTL_Image_Format_xiMono10MS52 = 0x8052000A,     // Pixel format 10bit
        XI_GenTL_Image_Format_xiMono12p_m9e3 = 0x8100100C,   // Pixel format 12bit
        XI_GenTL_Image_Format_xiMono16LS31 = 0x80310010,     // Pixel format 16bit
        XI_GenTL_Image_Format_xiPaBayerBG8 = 0x80000608,     // Bayer BG 8 Polarized 4 pixels
        XI_GenTL_Image_Format_xiPaBayerBG10 = 0x8000060A,    // Bayer BG 10 Polarized 4 pixels
        XI_GenTL_Image_Format_xiMono12pLS31 = 0x8131000C,    // Pixel format 12bit
        XI_GenTL_Image_Format_xiMono12LS31 = 0x8031000C,     // Pixel format 12bit
        XI_GenTL_Image_Format_xiMono16LS32 = 0x80320010,     // Pixel format 16bit
        XI_GenTL_Image_Format_xiMono12pLS32 = 0x8132000C,    // Pixel format 12bit
        XI_GenTL_Image_Format_xiMono12LS32 = 0x8032000C,     // Pixel format 12bit
        XI_GenTL_Image_Format_Mono32 = 0x01200111,           // Pixel format 32bit
        XI_GenTL_Image_Format_BayerRG32 = 0x80000420,        // Pixel format 32bit
        XI_GenTL_Image_Format_BayerGR32 = 0x80000320,        // Pixel format 32bit
        XI_GenTL_Image_Format_BayerBG32 = 0x80000120,        // Pixel format 32bit
        XI_GenTL_Image_Format_BayerGB32 = 0x80000220,        // Pixel format 32bit
        XI_GenTL_Image_Format_Mono32f = 0x80003020,          // Pixel format 32bit
        XI_GenTL_Image_Format_BayerBG32f = 0x80003120,       // Pixel format 32bit
        XI_GenTL_Image_Format_BayerGB32f = 0x80003220,       // Pixel format 32bit
        XI_GenTL_Image_Format_BayerGR32f = 0x80003320,       // Pixel format 32bit
        XI_GenTL_Image_Format_BayerRG32f = 0x80003420,       // Pixel format 32bit
        XI_GenTL_Image_Format_xiMono_m13e3 = 0x80004010,     // Pixel format 16bit
        XI_GenTL_Image_Format_BayerBG24 = 0x80000118,        // Pixel format 24bit
        XI_GenTL_Image_Format_BayerGB24 = 0x80000218,        // Pixel format 24bit
        XI_GenTL_Image_Format_BayerGR24 = 0x80000318,        // Pixel format 24bit
        XI_GenTL_Image_Format_BayerRG24 = 0x80000418,        // Pixel format 24bit
        XI_GenTL_Image_Format_Mono24 = 0x80000018,           // Pixel format 24bit
        XI_GenTL_Image_Format_xiBayerRG10MS41 = 0x8041040A,  // Pixel format 10bit
        XI_GenTL_Image_Format_xiBayerBG10MS41 = 0x8041010A,  // Pixel format 10bit
        XI_GenTL_Image_Format_xiBayerGR10MS41 = 0x8041030A,  // Pixel format 10bit
        XI_GenTL_Image_Format_xiBayerBG10pMS41 = 0x8141010A, // Pixel format 10bit
        XI_GenTL_Image_Format_xiBayerGR10pMS41 = 0x8141030A, // Pixel format 10bit
        XI_GenTL_Image_Format_xiBayerRG10pMS41 = 0x8141040A, // Pixel format 10bit
        XI_GenTL_Image_Format_xiBayerBG12MS41 = 0x8041010C,  // Pixel format 12bit
        XI_GenTL_Image_Format_xiBayerGR12MS41 = 0x8041030C,  // Pixel format 12bit
        XI_GenTL_Image_Format_xiBayerRG12MS41 = 0x8041040C,  // Pixel format 12bit
        XI_GenTL_Image_Format_xiBayerBG12pMS41 = 0x8141010C, // Pixel format 12bit
        XI_GenTL_Image_Format_xiBayerGR12pMS41 = 0x8141030C, // Pixel format 12bit
        XI_GenTL_Image_Format_xiBayerRG12pMS41 = 0x8141040C, // Pixel format 12bit
        XI_GenTL_Image_Format_xiBayerBG8MS41 = 0x80410108,   // Pixel format 8bit
        XI_GenTL_Image_Format_xiBayerGR8MS41 = 0x80410308,   // Pixel format 8bit
        XI_GenTL_Image_Format_xiBayerRG8MS41 = 0x80410408,   // Pixel format 8bit
        XI_GenTL_Image_Format_xiBayerBG11MS41 = 0x8041010B,  // Pixel format 11bit
        XI_GenTL_Image_Format_xiBayerGB11MS41 = 0x8041020B,  // Pixel format 11bit
        XI_GenTL_Image_Format_xiBayerGR11MS41 = 0x8041030B,  // Pixel format 11bit
        XI_GenTL_Image_Format_xiBayerRG11MS41 = 0x8041040B,  // Pixel format 11bit
        XI_GenTL_Image_Format_xiMono11MS41 = 0x8041000B,     // Pixel format 11bit
        XI_GenTL_Image_Format_xiBayerBG11pMS41 = 0x8141010B, // Pixel format 11bit
        XI_GenTL_Image_Format_xiBayerGB11pMS41 = 0x8141020B, // Pixel format 11bit
        XI_GenTL_Image_Format_xiBayerGR11pMS41 = 0x8141030B, // Pixel format 11bit
        XI_GenTL_Image_Format_xiBayerRG11pMS41 = 0x8141040B, // Pixel format 11bit
        XI_GenTL_Image_Format_xiMono11pMS41 = 0x8141000B,    // Pixel format 11bit
        XI_GenTL_Image_Format_xiMono8LS32 = 0x80320008,      // Pixel format 8bit
        XI_GenTL_Image_Format_xiMono8LS31 = 0x80310008,      // Pixel format 8bit
        XI_GenTL_Image_Format_xiPaBayerBG10p = 0x8100060A,   // Bayer BG 10p Polarized 4 pixels
        XI_GenTL_Image_Format_xiPaBayerBG12 = 0x8000060C,    // Bayer BG 12 Polarized 4 pixels
        XI_GenTL_Image_Format_xiPaBayerBG12p = 0x8100060C,   // Bayer BG 12p Polarized 4 pixels
        XI_GenTL_Image_Format_xiPaMono8 = 0x80000508,        // Mono 8 Polarized 4 pixels
        XI_GenTL_Image_Format_xiPaMono10 = 0x8000050A,       // Mono 10 Polarized 4 pixels
        XI_GenTL_Image_Format_xiPaMono10p = 0x8100050A,      // Mono 10p Polarized 4 pixels
        XI_GenTL_Image_Format_xiPaMono12 = 0x8000050C,       // Mono 12 Polarized 4 pixels
        XI_GenTL_Image_Format_xiPaMono12p = 0x8100050C,      // Mono 12p Polarized 4 pixels
    } XI_GenTL_Image_Format_e;

    //-------------------------------------------------------------------------------------------------------------------
    // xiAPI structures
    // structure containing description of image areas and format.
    typedef struct
    {
        DWORD Area0Left;        // Pixels of Area0 of image left.
        DWORD Area1Left;        // Pixels of Area1 of image left.
        DWORD Area2Left;        // Pixels of Area2 of image left.
        DWORD Area3Left;        // Pixels of Area3 of image left.
        DWORD Area4Left;        // Pixels of Area4 of image left.
        DWORD Area5Left;        // Pixels of Area5 of image left.
        DWORD ActiveAreaWidth;  // Width of active area.
        DWORD Area5Right;       // Pixels of Area5 of image right.
        DWORD Area4Right;       // Pixels of Area4 of image right.
        DWORD Area3Right;       // Pixels of Area3 of image right.
        DWORD Area2Right;       // Pixels of Area2 of image right.
        DWORD Area1Right;       // Pixels of Area1 of image right.
        DWORD Area0Right;       // Pixels of Area0 of image right.
        DWORD Area0Top;         // Pixels of Area0 of image top.
        DWORD Area1Top;         // Pixels of Area1 of image top.
        DWORD Area2Top;         // Pixels of Area2 of image top.
        DWORD Area3Top;         // Pixels of Area3 of image top.
        DWORD Area4Top;         // Pixels of Area4 of image top.
        DWORD Area5Top;         // Pixels of Area5 of image top.
        DWORD ActiveAreaHeight; // Height of active area.
        DWORD Area5Bottom;      // Pixels of Area5 of image bottom.
        DWORD Area4Bottom;      // Pixels of Area4 of image bottom.
        DWORD Area3Bottom;      // Pixels of Area3 of image bottom.
        DWORD Area2Bottom;      // Pixels of Area2 of image bottom.
        DWORD Area1Bottom;      // Pixels of Area1 of image bottom.
        DWORD Area0Bottom;      // Pixels of Area0 of image bottom.
        DWORD format;           // Current format of pixels. XI_GenTL_Image_Format_e.
        DWORD flags;            // description of areas and image.

    } XI_IMG_DESC, *LPXI_IMG_DESC;

    // structure containing information about incoming image.
    typedef struct
    {
        DWORD size; // Size of current structure on application side. When xiGetImage is called and size>=SIZE_XI_IMG_V2
                    // then GPI_level, tsSec and tsUSec are filled.
        LPVOID bp;  // Pointer to data. (see Note1)
        DWORD bp_size;     // Filled buffer size. (see Note2)
        XI_IMG_FORMAT frm; // Format of image data get from GetImage.
        DWORD width;       // width of incoming image.
        DWORD height;      // height of incoming image.
        DWORD nframe; // Frame number. On some cameras it is reset by exposure, gain, downsampling change, auto exposure
                      // (AEAG).
        DWORD tsSec;  // Seconds part of image timestamp (see Note3).
        DWORD tsUSec; // Micro-seconds part image timestamp (see Note3). Range 0-999999 us.
        DWORD GPI_level;   // Levels of digital inputs/outputs of the camera at time of exposure start/end (sample time
                           // and bits are specific for each camera model)
        DWORD black_level; // Black level of image (ONLY for MONO and RAW formats). (see Note4)
        DWORD padding_x;   // Number of extra bytes provided at the end of each line to facilitate image alignment in
                           // buffers.
        DWORD AbsoluteOffsetX;  // Horizontal offset of origin of sensor and buffer image first pixel.
        DWORD AbsoluteOffsetY;  // Vertical offset of origin of sensor and buffer image first pixel.
        DWORD transport_frm;    // Current format of pixels on transport layer.
        XI_IMG_DESC img_desc;   // description of image areas and format.
        DWORD DownsamplingX;    // Horizontal downsampling
        DWORD DownsamplingY;    // Vertical downsampling
        DWORD flags;            // description of XI_IMG.
        DWORD exposure_time_us; // Exposure time of this image in microseconds. (see Note5)
        float gain_db;          // Gain used for this image in deci-bells. (see Note6)
        DWORD acq_nframe;       // Frame number. Reset only by acquisition start. NOT reset by change of exposure, gain,
                                // downsampling, auto exposure (AEAG).
        DWORD image_user_data;  // (see Note7)
        DWORD exposure_sub_times_us[5]; // (see Note8)
        double data_saturation;         // Pixel value of saturation
        float wb_red;                   // Red coefficient of white balance
        float wb_green;                 // Green coefficient of white balance
        float wb_blue;                  // Blue coefficient of white balance
        DWORD lg_black_level;           // In case of multi gain channel readout, the black level low gain channel
        DWORD hg_black_level;           // In case of multi gain channel readout, the black level high gain channel
        DWORD lg_range;                 // In case of multi gain channel readout, the valid range of low gain channel
        DWORD hg_range;                 // In case of multi gain channel readout, the valid range of high gain channel
        float gain_ratio;               // Gain ration /low gain channel/ high gain channel

    } XI_IMG, *LPXI_IMG;

    //-------------------------------------------------------------------------------------------------------------------
    // Global definitions

#define SIZE_XI_IMG_V1 offsetof(XI_IMG, tsSec)       // structure size default
#define SIZE_XI_IMG_V2 offsetof(XI_IMG, black_level) // structure size with timestamp and GPI level information
#define SIZE_XI_IMG_V3 offsetof(XI_IMG, padding_x)   // structure size with black level information
#define SIZE_XI_IMG_V4                                                                                                 \
    offsetof(XI_IMG, AbsoluteOffsetX) // structure size with horizontal buffer padding information padding_x
#define SIZE_XI_IMG_V5 offsetof(XI_IMG, transport_frm)           // structure size with AbsoluteOffsetX, AbsoluteOffsetY
#define SIZE_XI_IMG_V6 offsetof(XI_IMG, img_desc)                // structure size with transport_frm
#define SIZE_XI_IMG_V7 offsetof(XI_IMG, DownsamplingX)           // structure size with img_desc
#define SIZE_XI_IMG_V8 (offsetof(XI_IMG, flags) + sizeof(DWORD)) // structure size with flags
#define SIZE_XI_IMG_V9 (offsetof(XI_IMG, gain_db) + sizeof(float))     // structure size with gain_db
#define SIZE_XI_IMG_V10 (offsetof(XI_IMG, acq_nframe) + sizeof(DWORD)) // structure size with acq_nframe
#define SIZE_XI_IMG_V11                                                                                                \
    (offsetof(XI_IMG, exposure_sub_times_us) + (5 * sizeof(DWORD))) // structure size with exposure_sub_times_us[5]
#define SIZE_XI_IMG_V12 (offsetof(XI_IMG, data_saturation) + sizeof(double)) // structure size with data_saturation
#define SIZE_XI_IMG_V13 (offsetof(XI_IMG, wb_blue) + sizeof(float)) // structure size with wb_red, wb_green, wb_blue
#define SIZE_XI_IMG_V14                                                                                                \
    (offsetof(XI_IMG, gain_ratio) +                                                                                    \
     sizeof(float)) // structure size with lg_black_level, hg_black_level, lg_range, hg_range, gain_ratio
#define XI_PRM_INFO_SETTABLE                                                                                           \
    ":settable" // Is parameter settable(xiSetParamInt(handler, XI_PRM_ABC XI_PRM_INFO_SETTABLE, param_value);)
#define XI_PRM_INFO_MIN ":min"       // Parameter minimum
#define XI_PRM_INFO_MAX ":max"       // Parameter maximum
#define XI_PRM_INFO_INCREMENT ":inc" // Parameter increment
#define XI_PRM_INFO ":info"          // Parameter value
#define XI_PRMM_REQ_VAL_BUFFER_SIZE                                                                                    \
    ":req_buf_size" // Parameter modifier for getting required value buffer size for xiGetParam (e.g.
                    // XI_PRM_DEVICE_MANIFEST XI_PRMM_REQ_BUFFER_SIZE can be used to get needed size of buffer for
                    // manifest)
#define XI_PRMM_DIRECT_UPDATE                                                                                          \
    ":direct_update"        // Parameter modifier for direct update without stopping the streaming. E.g. XI_PRM_EXPOSURE
                            // XI_PRMM_DIRECT_UPDATE can be used with this modifier
#define XI_MQ_LED_STATUS1 1 // MQ Status 1 LED selection value.
#define XI_MQ_LED_STATUS2 2 // MQ Status 2 LED selection value.
#define XI_MQ_LED_POWER 3   // MQ Power LED selection value.
#define XI_PRM_BPC "bpc"    // Legacy xiAPI parameter name for defect correction. Kept for backward compatibility.
    /*************************************************************************************/

#ifdef XIAPI_AS_APPLICATION
#undef XIAPI
#define XIAPI
#endif // XIAPI_AS_APPLICATION

    /*************************************************************************************/
    /**
       \brief Return number of discovered devices

       Returns the pointer to the number of all discovered devices.

       @param[out] pNumberDevices			number of discovered devices
       @return XI_OK on success, error value otherwise.
     */
    XIAPI XI_RETURN __cdecl xiGetNumberDevices(OUT PDWORD pNumberDevices);
    /**
       \brief Get device parameter

       Allows the user to get the current device state and information.
      Parameters can be used:XI_PRM_DEVICE_SN, XI_PRM_DEVICE_INSTANCE_PATH, XI_PRM_DEVICE_TYPE, XI_PRM_DEVICE_NAME

       @param[in] DevId						index of the device
       @param[in] prm						parameter name string.
       @param[in] val						pointer to parameter set value.
       @param[in] size						pointer to integer.
       @param[in] type						pointer to type container.
       @return XI_OK on success, error value otherwise.
     */
    XIAPI XI_RETURN __cdecl xiGetDeviceInfo(IN DWORD DevId, const char* prm, void* val, DWORD* size, XI_PRM_TYPE* type);
    /**
       \brief Initialize device

       This function prepares the camera's software for work.
       It populates structures, runs initializing procedures, allocates resources - prepares the camera for work.

            \note Function creates and returns handle of the specified device. To de-initialize the camera and destroy
       the handler xiCloseDevice should be called.

       @param[in] DevId						index of the device
       @param[out] hDevice					handle to device
       @return XI_OK on success, error value otherwise.
     */
    XIAPI XI_RETURN __cdecl xiOpenDevice(IN DWORD DevId, OUT PHANDLE hDevice);
    /**
            \brief Initialize selected device

            This function prepares the camera's software for work. Camera is selected by using appropriate enumerator
       and input parameters. It populates structures, runs initializing procedures, allocates resources - prepares the
       camera for work.

            \note Function creates and returns handle of the specified device. To de-initialize the camera and destroy
       the handler xiCloseDevice should be called.

            @param[in]  sel                     select method to be used for camera selection
            @param[in]  prm                     input string to be used during camera selection
            @param[out] hDevice					handle to device   @return XI_OK on success, error value
       otherwise.
            */
    XIAPI XI_RETURN __cdecl xiOpenDeviceBy(IN XI_OPEN_BY sel, IN const char* prm, OUT PHANDLE hDevice);
    /**
       \brief Uninitialize device

       Closes camera handle and releases allocated resources.

       @param[in] hDevice					handle to device
       @return XI_OK on success, error value otherwise.
     */
    XIAPI XI_RETURN __cdecl xiCloseDevice(IN HANDLE hDevice);
    /**
       \brief Start image acquisition

       Begins the work cycle and starts data acquisition from the camera.

       @param[in] hDevice					handle to device
       @return XI_OK on success, error value otherwise.
     */
    XIAPI XI_RETURN __cdecl xiStartAcquisition(IN HANDLE hDevice);
    /**
       \brief Stop image acquisition

       Ends the work cycle of the camera, stops data acquisition and deallocates internal image buffers.

       @param[in] hDevice					handle to device
       @return XI_OK on success, error value otherwise.
     */
    XIAPI XI_RETURN __cdecl xiStopAcquisition(IN HANDLE hDevice);
    /**
       \brief Return pointer to image structure

       Allows the user to retrieve the frame into LPXI_IMG structure.

       @param[in] hDevice					handle to device
       @param[in] timeout					time interval required to wait for the image (in
       milliseconds).
       @param[out] img						pointer to image info structure
       @return XI_OK on success, error value otherwise.
     */
    XIAPI XI_RETURN __cdecl xiGetImage(IN HANDLE hDevice, IN DWORD timeout, OUT LPXI_IMG img);
    /**
       \brief Set device parameter

       Allows the user to control device.

       @param[in] hDevice					handle to device
       @param[in] prm						parameter name string.
       @param[in] val						pointer to parameter set value.
       @param[in] size						size of val.
       @param[in] type						val data type.
       @return XI_OK on success, error value otherwise.
     */
    XIAPI XI_RETURN __cdecl xiSetParam(IN HANDLE hDevice, const char* prm, void* val, DWORD size, XI_PRM_TYPE type);
    /**
       \brief Get device parameter

       Allows the user to get the current device state and information.

       @param[in] hDevice					handle to device
       @param[in] prm						parameter name string.
       @param[in] val						pointer to parameter set value.
       @param[in] size						pointer to integer.
       @param[in] type						pointer to type container.
       @return XI_OK on success, error value otherwise.
     */
    XIAPI XI_RETURN __cdecl xiGetParam(IN HANDLE hDevice, const char* prm, void* val, DWORD* size, XI_PRM_TYPE* type);

    /*-----------------------------------------------------------------------------------*/
    // Set device parameter
    XIAPI XI_RETURN __cdecl xiSetParamInt(IN HANDLE hDevice, const char* prm, const int val);
    XIAPI XI_RETURN __cdecl xiSetParamFloat(IN HANDLE hDevice, const char* prm, const float val);
    XIAPI XI_RETURN __cdecl xiSetParamString(IN HANDLE hDevice, const char* prm, void* val, DWORD size);
    /*-----------------------------------------------------------------------------------*/
    // Get device parameter
    XIAPI XI_RETURN __cdecl xiGetParamInt(IN HANDLE hDevice, const char* prm, int* val);
    XIAPI XI_RETURN __cdecl xiGetParamFloat(IN HANDLE hDevice, const char* prm, float* val);
    XIAPI XI_RETURN __cdecl xiGetParamString(IN HANDLE hDevice, const char* prm, void* val, DWORD size);
    /*-----------------------------------------------------------------------------------*/
    // Get device info
    XIAPI XI_RETURN __cdecl xiGetDeviceInfoInt(IN DWORD DevId, const char* prm, int* value);
    XIAPI XI_RETURN __cdecl xiGetDeviceInfoString(IN DWORD DevId, const char* prm, char* value, DWORD value_size);
    /*-----------------------------------------------------------------------------------*/

    /*************************************************************************************/
    // XIMEA Offline Processing Interface
    // All functions can be called independently on camera device
    /*************************************************************************************/

    /*-----------------------------------------------------------------------------------*/
    // Workflow:
    //
    // xiProcessingHandle_t proc;
    // xiProcOpen(proc)
    // get cam_context (string) previously stored in acquisition time
    // xiProcSetParam(proc, XI_PRM_API_CONTEXT_LIST, cam_context, strlen(cam_context), xiTypeString)
    // while (in_image is available)
    // {
    //    xiProcPushImage(proc, in_image)
    //    xiProcPullImage(proc, out_image)
    //    use processed image (out_image)
    // }
    // xiProcClose(proc)
    /*-----------------------------------------------------------------------------------*/

    typedef void* xiProcessingHandle_t;

    /**
     * OpenProcessing
     * Opens new instance for Image Processing entity
     * @param[out] processing_handle New processing handle - valid on success
     */
    XIAPI XI_RETURN __cdecl xiProcOpen(xiProcessingHandle_t* processing_handle);

    /**
     * xiSetProcParam
     * Sets the selected parameter to processing
     * @param[in] processing_handle			Handle for processing
     * @param[in] prm						parameter name string.
     * @param[in] val						pointer to parameter set value.
     * @param[in] size						size of val.
     * @param[in] type						val data type.
     * @return XI_OK on success, error value otherwise.
     */
    XIAPI XI_RETURN __cdecl xiProcSetParam(
        xiProcessingHandle_t processing_handle, const char* prm, void* val, DWORD size, XI_PRM_TYPE type);

    /**
     * xiGetProcParam
     * Gets the selected parameter from processing
     * @param[in] processing_handle			Handle for processing
     * @param[in] prm						parameter name string.
     * @param[in] val						pointer to parameter set value.
     * @param[in] size						size of val.
     * @param[in] type						val data type.
     * @return XI_OK on success, error value otherwise.
     */
    XIAPI XI_RETURN __cdecl xiProcGetParam(
        xiProcessingHandle_t processing_handle, const char* prm, void* val, DWORD size, XI_PRM_TYPE type);

    /**
     * xiPushImage
     * Set unprocessed image to processing chain
     * @param[in] processing_handle Processing handle
     * @param[out] fist_pixel First byte of first pixel of image to be processed
     */
    XIAPI XI_RETURN __cdecl xiProcPushImage(xiProcessingHandle_t processing_handle, unsigned char* first_pixel);

    /**
     * xiPushImage
     * Set unprocessed image to processing chain
     * @param[in] processing_handle Processing handle
     * @param[in] Pointer to XI_IMG structure
     */
    XIAPI XI_RETURN __cdecl xiProcPushXiImg(xiProcessingHandle_t processing_handle, XI_IMG* image);

    /**
     * xiPullImage
     * Gets processed image from processing chain
     * @param[in] processing_handle Processing handle
     * @param[in] timeout_ms Processing handle
     */
    XIAPI XI_RETURN __cdecl xiProcPullImage(xiProcessingHandle_t processing_handle, int timeout_ms, XI_IMG* new_image);

    /**
     * CloseProcessing
     * Closes instance for Image Processing entity
     * @param processing_handle[out] Processing handle to be closed
     */
    XIAPI XI_RETURN __cdecl xiProcClose(xiProcessingHandle_t processing_handle);

    /*************************************************************************************/

#ifdef __cplusplus
}
#endif

#endif /* __XIAPI_H */
